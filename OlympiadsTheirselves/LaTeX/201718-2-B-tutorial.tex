\Tutorial
Формула відстані від початку координат до точки з координатами $(x;y)$ має вигляд $\sqrt{x^2+y^2}$ і легко слідує з теореми Піфагора (відстань рахується уздовж гіпотенузи, де довж\'{и}ни горизонтального та вертикального катетів рівні $|x|$\nolinebreak[1] та\nolinebreak[3] $|y|$ відповідно; ${|x|^2\,{=}\,x^2}$). Точка всер\'{е}дині кр\'{у}га або на межі, коли $\sqrt{x^2+y^2}\dib{{\<}}R$, і поза ним, коли $\sqrt{x^2+y^2}\dib{{>}}R$. Для деяких поєднань мови програмування та налаштувань компілятора надійніше переписати ці формули як ${x^2+y^2}\dib{{\<}}R^2$ та ${x^2+y^2}\dib{{>}}R^2$, щоб уникнути похибок (див.\nolinebreak[2] стор.\nolinebreak[3] \pageref{sec:floating-point}), але для багатьох % інших 
і~так, і~так правильно. Важливо також уникнути переповнень (стор.~\pageref{text:overflow-example}), для чого варто подати координати та радіус у типі, який поміщає значення не~лише сам\'{и}х координат та радіусів, а також і їхніх квадратів.

<<Стандартний шкільний>> алгоритм пошуку мінімума велить спочатку взяти за мінімум перший елемент послідовності, далі порівнювати кожен елемент з поточним мінімумом, і щоразу, коли черговий елемент менший мінімума, виправляти це, змінюючи значення мінімума на цей елемент. 
\ifAfour\else\par\fi
У~цій задачі ситуація ускладнюється тим, що треба шукати мінімум не~серед усіх, а\nolinebreak[3] лише серед тих, які строго більші\nolinebreak[3] $R$ (чи~$R^2$ у\nolinebreak[3] варіанті, де не~добувають корінь). Це\nolinebreak[3] суттєво ускладнює етап <<спочатку взяти за мінімум перший елемент>>, бо 
% той перший елемент може й не~задовольняти умову $\sqrt{x^2+y^2}\dib{{>}}R$ (чи\nolinebreak[2] ${x^2+y^2}\dib{{>}}R^2$). 
% перша (а також друга, третя,~\dots) 
\mbox{1-а} (а~також \mbox{2-а}, \mbox{3-я},~\dots) 
точка може бути всер\'{е}дині к\'{о}ла.
Це\nolinebreak[3] можна вирішити будь-якою однією з двох відомих модифікацій алгоритму пошуку мінімуму. 

(А)~Зберігати, крім мінімума\nolinebreak[2] \texttt{minSqrDist}, 
ще\nolinebreak[2] б\'{у}леву змінну \texttt{anyFound}, що означає <<чи~знайдено хоч одну точку за межами круга>>. Тоді % <<головне>> присвоєння 
можна написати так: 
\begin{ttfamily}{if (currSqrDist>R*R)\hspace{0.125em plus 0.5em} and\hspace{0.125em plus 0.5em} (not~anyFound\hspace{0em plus 0.25em} or\hspace{0em plus 0.25em} (currSqrDist<minSqrDist)) then minSqrDist:=currSqrDist}\end{ttfamily}. Тобто, оновлювати мінімум, коли поточна точка за\nolinebreak[3] межами круга і при цьому або перша така, або її відстань менша за раніше знайдену мінімальну.
%%% \ERROR \begin{color}{red}\begin{Huge}{link to ready solution here}\end{Huge}\end{color}

(Б)~Ініціалізувати мінімум не~першим значенням, а <<плюс нескінченістю>>, яка конкретно у цій задачі може бути, наприклад, вигляду \texttt{2100100100}: це\nolinebreak[2] \mbox{число} більше будь-якого реально можливого, а~отже при знаходженні першої \mbox{точки} поза кругом обов'язково буде замінене на відстань до цієї точки. <<\mbox{Головне}>> присвоєння набуває більш очевидного вигляду \begin{ttfamily}{if\nolinebreak[2] (currSqrDist>R*R) and (currSqrDist<minSqrDist) then minSqrDist:=currSqrDist}\end{ttfamily}.

В обох розглянутих підходах, першу точку слід обробляти 
так само, як і всі подальші.

Ще\nolinebreak[3] питання: які тут потрібні масиви? Щоб\nolinebreak[2] зберігати координати, % залежно від рівня знань учасника, 
можна використати або два окремі масиви \texttt{x} та~\texttt{y}, або масив записів (структур) чи об'єктів, де кожен елемент містить обидва п\'{о}ля \texttt{x} та~\texttt{y}. Але\nolinebreak[2] координати взагалі не~дуже-то й треба складати у масив, їх цілком можна читати й тут\nolinebreak[3] же обробляти і забувати. 
А~відстані (чи\nolinebreak[2] квадрати відстаней), мабуть, легше все-таки зберегти у\nolinebreak[3] масиві.\linebreak[2] Адже потрібно вивести \emph{номери всіх} потрібних точок, а\nolinebreak[2] поки не~завершено обробку всіх точок, не~можна бути впевненим, що\nolinebreak[2] поточна точка на мінімальній відстані (бо\nolinebreak[3] пізніше може знайтися на ще меншій). Так\nolinebreak[3] що\nolinebreak[2] легше першим проходом знайти мінімальну відстань (чи її квадрат), а др\'{у}гим повиводити номери всіх точок на такій відстані.
%
Приклади таких реалізацій мовою Pascal:
\IdeOne{wvA2kg}\nolinebreak[2] (підхід~А),\linebreak[2]
\IdeOne{YgNUld}\nolinebreak[2] (підхід~Б).

В~принципі можна й обійтися зовсім без масиву. Наприклад, так: щоразу, коли знаходиться нова точка на такій самій наразі мінімальній відстані, її номер дописується у вихідний файл, а щоразу, коли мінімум оновлюється, бо нова точка має строго меншу відстань, файл результату очищується й номер цієї точки пишеться у щойно очищений файл. Зокрема, саме так організований код \IdeOne{jSPTGR}, що використовує \verb"assign(output,'output.txt')" та \verb"rewrite(output)", при здачі в \EjudgeCkipoName{} мовою \verb"fpc" працює правильно. І\nolinebreak[3] ця\nolinebreak[2] реалізація працювала~б навіть при кількості точок $10^7$ та обмеженні пам'яті 4$\,$Мб (втім, зараз це~не~треба). Тут важливо, що програма працює з файлом, а~не~екраном; через\nolinebreak[2] це, конкретно цей код (один з дуже небагатьох) не~працює ні безпосередньо на \IdeOneName, ні якщо здати його на \EjudgeCkipoName, прибравши оператори \texttt{assign}. Міркування <<сказано ``або\nolinebreak[3] екран, або\nolinebreak[3] \texttt{output.txt}'', значить нема ніякої відмінності>> пра\-ви\-льне часто, але якщо з файлами намагаються працювати якось хитро, то\nolinebreak[3] не\nolinebreak[3] завжди. З~цієї~ж причини автори збірника не~гарантують, чи\nolinebreak[3] всіма мовами програмування доступний цей прийом.

Ще можна діяти подібно до попереднього абзацу, але номери точок, відстані яких рівні поточному мінімуму, не~писати у~файл, а~складати в деяку проміжну структуру. Мовою~C++ найзручнішим здається \texttt{vector} (з~використанням \verb"push_back" та \verb"clear"; див.\nolinebreak[2] \IdeOne{D21hEr}). Мовами Java та C\#\nolinebreak[3] --- \verb"StringBuilder", де формувати зразу рядкове подання відповіді, теж з очищенням при знаходженні ще\nolinebreak[3] меншого мінімуму; див.\nolinebreak[2] \IdeOne{3VmbDa}\nolinebreak[2] (Java; якщо замінити \verb"Scanner" на \verb"StreamTokenizer", читання відбуватиметься швидше, див.\nolinebreak[2] також стор.~\pageref{text:java-Scanner-versus-StreamTokenizer}). Але\nolinebreak[2]  навряд\nolinebreak[3] чи якийсь з цих способів легший і простіший, ніж згадане першим використання масиву відстаней (чи\nolinebreak[3] квадратів відстаней) і двох проходів. Казати~ж <<формувати відповідь у \verb"StringBuilder" краще тим, що потреб\'{у}є менше пам'яті, бо\nolinebreak[2] зберігаються номери не~всіх точок, а~лише мінімальних (за\nolinebreak[3] відстанню)>>\nolinebreak[3] --- правда лише частково, бо\nolinebreak[2] з\nolinebreak[3] тими обмеженнями, які\nolinebreak[3] є, ця\nolinebreak[2] різниця неважлива, а\nolinebreak[3] якби задачу ставили у\nolinebreak[2] жорсткому варіанті <<$10^7$~точок, 4$\,$Мб\nolinebreak[3] пам'яті>>, то, мабуть, дали~б частину тестів, де $9{,}99{\cdot}10^6$ з усіх $10^7$ точок на однаковій мінімальній відстані, й пам'яті на \verb"StringBuilder" не~вистачило~б.


Само собою, в будь-якому розв'язку треба не~забувати правильно виводити відповідь~0.

