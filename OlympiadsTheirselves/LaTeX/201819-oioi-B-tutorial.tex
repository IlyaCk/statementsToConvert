\Tutorial
З'ясуємо, як обчислювати дисковий розмір окремо взятого файлу. Надалі вважаємо, що розмір файла у\nolinebreak[3] байтах лежить у\nolinebreak[3] змінній \texttt{f\_len}, розмір кластера у\nolinebreak[3] змінній \texttt{cluster}.

У~багатьох мовах (C/C++,\nolinebreak[2] Java, Python, C\#, pascalABC\nolinebreak[3] --- с\'{а}ме~ABC, а~не~будь-який Паскаль)
є функція \texttt{ceil} (у~C\#,\nolinebreak[2] \texttt{Ceiling}), яка виконує округлення вгору: якщо число-аргумент ціле, то результат дорівнює самому цьому числу, а\nolinebreak[3] якщо дробове, то за результат береться найменше ціле число, більше за аргумент. Отже, кількість кластерів дорівнює \texttt{ceil(f\_len/cluster)}. Багатьма мовами програмування символ-у-символ так, але\nolinebreak[2] не\nolinebreak[3] всіма. Слід забезпечити, щоб це було ділення за дробовими, а~не~цілочисельними, правилами (наприклад, \texttt{17/5} повинно давати\nolinebreak[3] \texttt{3.4}, а~не~\texttt{3}). У~Pascal та Python3 це вийде сам\'{е}; в~інших це\nolinebreak[3] можна зробити записом у~стилі ``\texttt{ceil((1.0*len)/cluster)}'', або записом у~стилі ``\texttt{ceil(((double)len)/cluster)}'' (це~називають \emph{приведенням типів}, англ. \emph{typecast}), або оголосивши самі змінні \texttt{f\_len} та \texttt{cluster} у типі з рухомою комою. Детальніше варто розбиратися за підручником з конкретної мови програмування.

Можна й обійтися без функції \texttt{ceil}. 
Наприклад, спочатку цілочисельним діленням (``\texttt{\mbox{f\_len}\nolinebreak[3] \mbox{div}\nolinebreak[2] cluster}''\nolinebreak[2] у\nolinebreak[3] Pascal,\linebreak[2] ``\texttt{\mbox{f\_len//}\nolinebreak[3]\mbox{cluster}}''\nolinebreak[3] у\nolinebreak[3] Python3, ``\texttt{\mbox{f\_len/}\nolinebreak[3]\mbox{cluster}}'' у \mbox{C-подіб}\-\nolinebreak[3]них мовах та Python2; все\nolinebreak[2] це за\nolinebreak[2] умови, що обидві змінні \texttt{f\_len} та \texttt{cluster} цілочисельні) порахувати кількість повних кластерів, зайнятих файлом; потім подивитися, чи\nolinebreak[3] розмістився файл повністю в цих кластерах, чи потрібен ще~один. Ще~один кластер потрібен тоді й тільки тоді, коли він неповний, тобто при діленні є залишок, тобто ``\texttt{\mbox{f\_len}\nolinebreak[3] \mbox{mod}\nolinebreak[2] cluster\nolinebreak[2]\hspace{0.125 em plus 0.125pt}\mbox{{<}{>}\hspace{0.125 em}0}}''\nolinebreak[2] (Pascal),\linebreak[2] ``\texttt{\mbox{f\_len\%}\nolinebreak[3]\mbox{cluster}\nolinebreak[3]\hspace{0.125 em plus 0.125pt}\mbox{!=\hspace{0.125 em}0}}'' (\mbox{C-подібні} та Python).

Коли пораховані дискові розміри окремих файлів, лишається тільки подавати їх.

Слід переконатися, що програма правильно працює у <<крайніх>>, але дозволених умовою задачі, випадках: (1)~файл розміром 0\nolinebreak[3] байтів займає 0\nolinebreak[3] байтів; (2)~якщо кількість файлів~0, <<вони усі сумарно>> займають 0\nolinebreak[3] байтів; (3)~розмір кластера може дорівнювати 1\nolinebreak[3] байту; це\nolinebreak[3] суперечить реаліям і сам\'{о}му смислу кластерів, але не~заборонено умовою задачі.

Неприємною несподіванкою може бути також те, що у Free\nolinebreak[2] Pascal тип \texttt{integer} 16-бітовий, а\nolinebreak[2] отже не~може вмістити в~собі потрібні значення (див.\nolinebreak[3] також стор.~\pageref{text:overflow-example}).
