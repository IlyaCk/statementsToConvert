\Tutorial

\def\tabbb{\hspace*{1em}}

\myflfigaw{%
% \ifAfour\hspace*{-1mm}\begin{minipage}{15.5em}\else\begin{minipage}{15.25em}\fi
\hspace*{-1mm}\begin{minipage}{15.5em}
\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}for a:=1 to V do\\
\tabbb{}for b:=1 to V do\\
\tabbb\tabbb{}for c:=1 to V do begin\\
\tabbb\tabbb\tabbb{}V2:=a*b*c;
\tabbb\tabbb\tabbb{}S2:=2*(a*b+a*c+b*c);\\
\tabbb\tabbb\tabbb{}if (V2=V)and(S2=S) then\\
\tabbb\tabbb\tabbb\tabbb{}writeln(a,' ', b,' ', c)
\tabbb\tabbb{}end\end{alltt}\end{small}\end{minipage}}
\MyParagraph{Найпростіший підхід ($\approx$ 90 балів з 350).}
Можна просто перебрати всі можливі поєднання \texttt{a},\nolinebreak[2] \texttt{b},\nolinebreak[3] \texttt{c} (кожна змінна у проміжку від\nolinebreak[3] 1 до~\texttt{V}) наведеними вкладеними циклами. У~ньому мається на увазі, що \texttt{V} та \texttt{S}\nolinebreak[3] --- введені у вхідних даних об'єм та площа поверхні,\linebreak[2] а \texttt{V2} та \texttt{S2}\nolinebreak[3] --- обчислені при поточних значеннях \texttt{a},\nolinebreak[2] \texttt{b},\nolinebreak[3] \texttt{c}. Трійки перебиратимуться якраз у тому порядку, як їх треба виводити, тож такий розв'язок повинен набрати свої $\approx$~90~балів. Але не~більше (принаймні, не~значно більше), бо три вкладені цикли, кожен від\nolinebreak[3] 1 до\nolinebreak[3] $V$, працюватимуть $\Theta(V^3)$ часу, і вже при $V\,{\approx}\,1000$ виконання не~вкладатиметься у ліміт часу.

Навіть тут може бути важливим не~<<жмотитися>> на типах даних. Значення добутку \texttt{a*b*c} може значно перевищувати значення окремих змінних \texttt{a},\nolinebreak[2] \texttt{b},\nolinebreak[3] \texttt{c}. І~намагання <<зекономити>>, впихнувши їх у \mbox{16-біто}\-вий тип, призведе до переповнень (див. також стор.~\pageref{text:overflow-example}) при обчисленні \texttt{a*b*c}. Наприклад, при 
${V\,{=}\,188}$,
${S\,{=}\,126}$,
якщо \texttt{a},\nolinebreak[2] \texttt{b},\nolinebreak[3] \texttt{c} перебирають всі значення від~1 до\nolinebreak[3] $V$, буде розглянуто 
% в~тому числі й 
зокрема і 
трійку 
${\texttt{a}\,{=}\,68}$,
${\texttt{b}\,{=}\,97}$,
${\texttt{c}\,{=}\,159}$.
Взагалі-то ${68\cdot97\cdot159}\dibbb{{=}}1048764_{Dec}\dibbb{{=}}100000000000010111100_{Bin}$, але якщо рахувати це у \mbox{16-біто}\-вому типі з переповненням, то від цього числа залишиться тільки $10111100_{Bin}\dibbb{{=}}188_{Dec}$. Аналогічно й  
$2\cdot(
68\cdot97\dib{{+}}
68\cdot159\dib{{+}}
97\cdot159)\dibbb{{=}}65662_{{Dec}}\dibbb{{=}}10000000001111110_{Bin}$ перетвориться у $1111110_{Bin}\dib{{=}}126_{Dec}$, і таким чином трійка (68;97;159) та її перестановки будуть неправильно виведені як буцімто відповіді для 
${V\,{=}\,188}$,
${S\,{=}\,126}$,
хоча фактично ними\nolinebreak[2] не~є. Вибирайте тип даних <<із~запасом>>, і цієї проблеми не~буде.
У~більш ефективних алгоритмах, де значення змінних можуть бути ще\nolinebreak[3] більшими, важливість уникнення переповнень ще\nolinebreak[3] більша.

\MyParagraph{Переходимо від трьох вкладених циклів до двох ($\approx$~150~балів, тобто +$\approx$~60~балів відносно попереднього).}
Нам потрібно, щоб було ${a\cdot b\cdot c}\dib{{=}}V$. (Крім того, ще й ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)\dibbb{{=}}S$, але це на пару хвилин відкладемо, зосередившися спочатку на ${a\cdot b\cdot c}\dib{{=}}V$.) 
Коли два (а~не~три) вкладені цикли вже вибрали поточні значення як~\texttt{a}, так і~\texttt{b}, враховуючи, що значення \texttt{V} ще раніше прочитане у вхідних даних \nolinebreak[3] --- нема потреби \emph{перебирати} можливі значення~\texttt{c}. Якщо таке~\texttt{c} існує, то воно дорівнює $\frac{V}{ab}$. Точніше кажучи, якби $c$ могло бути дробовим, його завжди можна було~б обчислювати як $\frac{V}{ab}$; але треба, щоб $c$ було цілим. Тому варто міркувати так: перевірити, чи \texttt{V} кратне добутку \texttt{a*b}; якщо ні, то для цих \texttt{a},\nolinebreak[3] \texttt{b} підібрати~\texttt{c} неможливо й треба далі перебирати наступні \texttt{a},\nolinebreak[3] \texttt{b};\linebreak[3] якщо\nolinebreak[3] ж кратне, то можна \emph{знайти}~\texttt{c} (не~перебираючи!), як \texttt{c:=V\nolinebreak[3] div(a*b)} (Pascal), \texttt{c=V//(a*b)} (Python~3), \dots (допишіть своєю мовою програмування самостійно). А~тепер, для підібраних циклами \texttt{a},\nolinebreak[3] \texttt{b} і обчисленого за формулою~\texttt{c}, можна перевірити також умову ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)\dibbb{{=}}S$ і прийняти остаточне рішення, чи\nolinebreak[3] виводити поточну трійку \texttt{a},\nolinebreak[2] \texttt{b},\nolinebreak[3] \texttt{c}. Виведення трійок все\nolinebreak[3] ще можна робити відразу~ж, як відповідна трійка була знайдена. Складність такого алгоритму $\Theta(V^2)$, тож повинні проходити чи\nolinebreak[3] то\nolinebreak[3] всі, чи\nolinebreak[3] то\nolinebreak[2] хоча~б більшість тестів, у~яких ${V\,{\<}\,10^4}$.

\MyParagraph{Пропускаємо безперспективні ітерації зовнішнього циклу та уточнюємо м\'{е}жі вкладеного циклу ($\approx$~210~балів, тобто +$\approx$~60~балів відносно попереднього).}
Знаючи, що потім треба буде перевіряти, чи \texttt{V} кратне\nolinebreak[2] \texttt{a*b}, варто звернути увагу, що для <<\texttt{V}\nolinebreak[3] кратне\nolinebreak[2] \mbox{\texttt{a*b}}>> необхідно, але не~достатньо, щоб \texttt{V} було кратним~\texttt{a}. Інакше кажучи, якщо \texttt{V}\nolinebreak[3] кратне~\texttt{a}, то буде чи не~буде \texttt{V} кратним добутку\nolinebreak[2] \texttt{a*b}, залежить в\nolinebreak[2] тому числі й від~\texttt{b}, треба перевіряти; але якщо \texttt{V}\nolinebreak[2] не~кратне сам\'{о}му лише~\texttt{a}, то тим\nolinebreak[2] паче не~буде кратним добутку\nolinebreak[2] \texttt{a*b}, і для таких~\texttt{a} можна взагалі не~запускати вкладений цикл перебору~\texttt{b}. Це\nolinebreak[3] істотна оптимізація, бо у чисел насправді не~буває дуже вже багато дільників; разом з тим, важко виразити конкретну асимпотичну оцінку того, скільки дільників може бути у числ\'{а}. 

Ще\nolinebreak[3] одна оптимізація (яку в~принципі можна використати й незалежно від оптимізації минулого абзацу, але краще, якщо разом із нею)\nolinebreak[3] --- коли вже є поточне значення~\texttt{a}, то обчислити 
\texttt{V\_div\_a:=\nolinebreak[3]\mbox{V div a}} (Pascal), воно~ж 
\texttt{V\_div\_a~=\nolinebreak[3] \mbox{V//a}} (Python~3),\nolinebreak[2] \dots 
(допишіть своєю мовою програмування самостійно), 
і вкладений цикл по~\texttt{b} крутити не~до~\texttt{V}, а до\nolinebreak[3] \texttt{V\_div\_a}. 
Причому, крім того, що ця оптимізація пришвидшує виконання програми, вона має ще\nolinebreak[3] одну приємну рису: коли цикл по~\texttt{b} крутиться лише до\nolinebreak[3] \texttt{V\_div\_a}, чи\nolinebreak[3] то\nolinebreak[3] зникає, чи\nolinebreak[3] то\nolinebreak[3] сильно зменшується (залежно від того, як\nolinebreak[3] написати решту коду) ризик переповнень.
% , подібних до розібраного наприкінці аналізу найпростішого підходу.
Якби була запроваджена лише ця оптимізація (без оптимізації попереднього абзацу), час роботи склав\nolinebreak[3] би $\Theta(V\log{}V)$. (Ідея доведення: $V\dib{{+}}\frac{V}{2}\dib{{+}}\frac{V}{3}\dib{{+}}\ldots\dib{{+}}\frac{V}{V}\dibbb{{=}}V\cdot\bigl(1\dib{{+}}\frac{1}{2}\dib{{+}}\frac{1}{3}\dib{{+}}\ldots\dib{{+}}\frac{1}{V}\bigr)\dibbb{{\approx}}V\cdot\bigl(\int\nolimits_{1}^{V}{\frac{1}{x}dx}\bigr)\dibbb{{=}}V\cdot\biggl(\bigl.\ln x\bigr|_{1}^{V}\biggr)\dibbb{{=}}V\cdot\ln{}V$. Автор розбору в~курсі, що оліміпада не~лише для \mbox{11-х} класів, а молодші не~зобов'язані знати інтеграли. Але це не~важливо, бо інтеграл використаний лише в доведенні, а~не~в~коді; здогадатися, що вищеописані зміни в коді повинні якось та скоротити перебір, цілком можна і не~знаючи інтегралів.)

Разом узяті, оптимізації двох минулих абзаців покращують час роботи ще\nolinebreak[3] сильніше (але дуже важко виразити аналітично, наскільки с\'{а}ме). 
\emph{Якщо} поєднувати ці оптимізації, то замість перевірки <<чи\nolinebreak[3] \texttt{V} кратне~\texttt{a*b}>> варто використовувати перевірку <<чи\nolinebreak[3] \texttt{V\_div\_a} кратне~\texttt{b}>>, вона повинна працювати дещо швидше; але це вже оптимізація у~деталях, яка не~така й важлива.

Наскільки відомо автору задачі, подальшим <<вилизуванням>> таких деталей можна добитися, щоб розв'язок 
% пройшов також і передостанній блок і 
набрав\nolinebreak[2] 
240\nolinebreak[3] балів з~350 (тільки\nolinebreak[2] не~факт, чи\nolinebreak[3] будь-якою мовою програмування), 
% але\nolinebreak[3] не~всі\nolinebreak[3] 100\%.
але\nolinebreak[3] не~більше.


\MyParagraph{100\%-й розв'язок.}
Враховуючи симетричність формул \nolinebreak[3] ${a\,{\cdot}\,b\,{\cdot}\,c}$ та ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)$ відносно $a$,~$b$,~$c$, легко бачити, що якщо деяка трійка $a$,~$b$,~$c$ є розв'язком, то й усі її перестановки теж є розв'язками. 
Тому, досить шукати лише трійки, в~яких ${a\<b\<c}$, а~решту формувати з~них, переставляючи ці три числа. 
(Якщо значення $a$,~$b$,~$c$ всі різні, таких 
перестановок~6, 
а~с\'{а}ме:
$(a,b,c)$,
$(a,c,b)$,
$(b,a,c)$,
$(b,c,a)$,
$(c,a,b)$,
$(c,b,a)$;
% перестановок ${3!\,=6}$, 
якщо всі однакові, то лише~1 (як\nolinebreak[3] не\nolinebreak[3] переставляй однакові ч\'{и}сла, виходить те\nolinebreak[3] с\'{а}мо); 
якщо два однакові, а\nolinebreak[3] третє інше, 
то~3 (зокрема, 
при $a\,{\neq}\,b\,{=}\,c$ це будуть
$(a,b,b)$,
$(b,a,b)$,
$(b,b,a)$;\hspace{0.5 em plus 1em}
при $a\,{=}\,b\,{\neq}\,c$\nolinebreak[3] --- 
$(a,a,c)$,
$(a,c,a)$,
$(c,a,a)$;\hspace{0.5 em plus 1em}
при $a\,{=}\,c\,{\neq}\, b$\nolinebreak[3] --- 
$(a,b,a)$,
$(a,a,b)$,
$(b,a,a)$).)

\noindent\hrulefill

\noindent
(Фраза <<\emph{досить} шукати лише~\dots\dots\dots>> досить важлива, зокрема, том\'{у}, що грамотний аналіз такого роду спостережень часто є важливим для побудови ефективних алгоритмів. Бувають ситуації, коли варто сказати <<воно-то досить цим обмежитися, але ж можна й не~обмежуватися; навіщо нам бр\'{а}ти на себе додаткові обмеження, якщо цього навіть не~просять?>>. А\nolinebreak[3] бувають  ситуації, коли варто сказати <<і\nolinebreak[3] це\nolinebreak[3] добре, що можна обмежитися, бо\nolinebreak[3] це\nolinebreak[3] зменшує перелік варіантів, які слід розглянути; шукати за межами цих варіантів\nolinebreak[3] --- воно-то можна, але навіщо, якщо на пошук за межами треба виратити купу часу, й це все\nolinebreak[3] одно не~дасть нічого нового?>>. Важливо навчитися визначати, яка з цих реакцій доречніша для конкретної ситуації. Найчастіше, це залежить від таких факторів: (1)~наскільки сильно це обмеження дозволяє скоротити перебір? (2)~наскільки складнішим чи простішим від урахування цього обмеження стає код?)

\noindent\hrulefill

З~разом узятих ${a\<b\<c}$ та ${V\,{=}\,a\,{\cdot}\,b\,{\cdot}\,c}$ випливає ${a\,{\<}\,\sqrt[3]{V}}$; навіть найбільше обмеження на~$V$ становить $V\,{\<}\,10^{18}$, тож маємо ${a\dib{{\<}}\sqrt[3]{V}\dib{{\<}}\sqrt[3]{10^{18}}\dib{{=}}10^6}$; значить, навіть при найбільших обмеженнях, всіх можливих претендентів на значення~$a$ можна перебрати. Як\nolinebreak[3] вже згадано вище, можна зразу перевіряти кожне~$a$, чи~є воно дільником~$V$, і якщо не~є, то пропускати.

А~при відомих $V$, $S$, $a$ вже можна розв'язувати відносно $b$, $c$ систему 
$$
\left\{
\begin{array}{l}
V = abc, \\
S = 2(ab+bc+ac).
\end{array}
\right.
$$
Наприклад, виразимо з першого рівняння ${c\,{=}\,\frac{V}{ab}}$ і підставимо у друге; вийде
$S \dibbb{{=}} 2{\cdot}(ab\dib{{+}}b\frac{V}{ab}\dib{{+}}a\frac{V}{ab}) \dibbb{{=}}
2{\cdot}(ab\dib{{+}}\frac{V}{a}\dib{{+}}\frac{V}{b})$. Нагадаємо, що $V$ та\nolinebreak[3] $S$ відомі, бо\nolinebreak[2] задані у\nolinebreak[2] вхідних даних, а\nolinebreak[2] $a$\nolinebreak[2] відоме, бо його перебирає цикл; таким чином, змінною лишається тільки~$b$, і, враховуючи $b\,{\neq}\,0$ (при\nolinebreak[2] 0 не~виходило\nolinebreak[3] б ненульового $V\,{=}\,abc$), рівняння можна перетворити так, щоб воно стало квадратним відносно~$b$:


% \begin{longtable}{@{}p{0.6\textwidth}|l@{}}
\begin{longtable}{@{}p{0.7\textwidth}|l@{}}
взяли початок і кінець попереднього ланцюжка рівностей
&
$S=2\cdot(ab+\frac{V}{a}+\frac{V}{b})$\vphantom{$\displaystyle\frac{(a)}{a}$}
\\\hline
домножили на~$b$ й поділили на~2
&
$\frac{S}{2}b = ab^2 + \frac{V}{a}\cdot b + V$\vphantom{$\displaystyle\frac{(a)}{a}$}
\\\hline
перенісши все в один бік, привели до стан\-дарт\-ного вигляду квадратного рівняння
&
$a\cdot b^2 + \bigl(\frac{V}{a}-\frac{S}{2}\bigr)\cdot b + V = 0$\vphantom{$\displaystyle\frac{(a)}{a}$}
\end{longtable}

% % % \begin{Large}

% % % (сюди ще є що дописувати, але цей шматок ще~не~готовий, бо життя важке й несправедливе)

% % % \end{Large}

% % % З~точки зору <<чистої>> математики, далі слід підставити ці коефіцієнти у формулу коренів квадратного рівняння й отримати формулу
% % % $$
% % % c = \frac{-(\frac{V}{a}-\frac{S}{2}) \pm\sqrt{(\frac{V}{a}-\frac{S}{2})^2 - 4\cdot a \cdot V}}{2\cdot a}\ldots
% % % $$
% % % Але якщо згадати, що олімпіада все-таки з інформатики, то значно кращим є інший варіант: зробити, щоб у більшій частині коду за $a$, $b$, $c$ були позначені р\'{е}бра паралелепіпеда, але щоб була підпрограма (функція чи метод) розв'язування квадратного рівняння, всер\'{е}дині якої $a$, $b$, $c$ позначають вже коефіцієнти квадратного рівняння; те, що коефіцієнтами квадратного рівнняня є $a$, ${\frac{V}{a}\,{-}\,\frac{S}{2}}$ та~$V$, доцільно задавати аргументами, з якими викликається ця підпрограма роз\-в'\-я\-зу\-вання квадратного рівняння.

% % % В будь-якому разі бажано (а\nolinebreak[3] якщо писати підпрограму роз\-в'\-я\-зу\-вання квадратного рівняння\nolinebreak[3] --- дуже-дуже бажано) розібратися, що робити з тим, що стандартна формула коренів квадратного рівняння може дати два корені: чи\nolinebreak[2] треба розглядати обидва, чи\nolinebreak[2] досить один, і\nolinebreak[2] якщо один, то\nolinebreak[2] який? Тут варто згадати, що після фіксації $a$ перебором у циклі все ще лишилося справедливим твердження <<якщо трійка $(a, b, c)$ є розв'язком для потрібних $V$,~$S$, то й трійка $(a, c, b)$ теж>>. (Причому, враховуючи рівність $bc\,{=}\,\frac{V}{a}$ та вигляд квадратного рівняння $a\cdot c^2 + \bigl(\frac{V}{a}-\frac{S}{2}\bigr)\cdot c + V = 0$, це має зв'язок також із теоремою Вієта.) Тому, якщо ми візьмемо обидва корені $c_1$,~$c_2$, і\nolinebreak[2] для кожного окремо обчислимо $b_1\,{=}\,\frac{V}{a\cdot c_1}$ та $b_2\,{=}\,\frac{V}{a\cdot c_2}$, то отримаємо, що 
% % % %  $b_1\,{=}\,c_2$, $b_2\,{=}\,c_1$, тобто 
% % % пари $(b_1,c_1)$ та $(b_2,c_2)$ відрізняються лише порядком (${c_2\,{=}\,b_1}$, ${b_2\,{=}\,c_1}$). Том\'{у} здається логічним розглядати лише один з коренів квадратного рівняння. Будь-який. Інший все\nolinebreak[3] одно буде отриманий як $b\,{=}\,\frac{V}{ac}$.

% % % Отже, розв'язати задачу можна так: перебрати циклом за~$a$ значення від~1 до~$\lfloor\sqrt[3]{V}\rfloor$, і, для тих, які є дільниками~$V$, знайти спочатку дискримінант квадратного рівняння $a\cdot c^2 + \bigl(\frac{V}{a}-\frac{S}{2}\bigr)\cdot c + V = 0$; якщо він від'ємний, то \emph{конкретно це~$a$} не~дасть розв'язку, треба переходити до наступного; якщо невід'ємний, знайти $c$ як будь-який із коренів цього квадратного рівняння, на основі нього визначити $b\,{=}\,\frac{V}{ac}$; якщо отримані за цими обчисленнями значення $b$, $c$ є натуральними, то сформувати з $(a,b,c)$ всі різні перестановки й додати їх у відповідь. 

Нагадуємо, що після того, як розв'яжемо це квадратне рівняння відносно~$b$, можна виразити $c\,{=}\,\frac{V}{ab}$, а\nolinebreak[3] $a$\nolinebreak[2] вже\nolinebreak[3] відоме, бо\nolinebreak[3] його перебирає цикл, і\nolinebreak[3] можна сформувати всі можливі перестановки знайдених\nolinebreak[2] $a$,\nolinebreak[3] $b$,~$c$ та додати їх у відповідь.
% % % Відповідь при цьому повинна формуватися у пам'яті (поки\nolinebreak[3] що не~виводитися), бо є вимога вивести трійки-відповіді обов'язково у вказаному порядку. А\nolinebreak[3] 
Приклад~4 з\nolinebreak[3] умови показує (більш того, це можна було~б помітити, навіть якби такого прикладу в~умові не~було), що трійки, утворені перестановками одних і тих самих $(a,b,c)$, не~завжди йдуть у відповіді підряд. 
Том\'{у} треба спочатку сформувати потрібні трійки у пам'яті, а\nolinebreak[3] потім, коли вони вже всі будуть сформовані, вивести\nolinebreak[2] їх у\nolinebreak[3] потрібному порядку. Тобто можна, наприклад, відсортувати масив (наприклад, двовимірний, переставляючи цілі рядки; або, наприклад, це може бути масив структур з полями $(a,b,c)$).

В~умові сказано, що кількість трійок-відповідей гарантовано менша~100. У~фактично використаних тестах навіть не~перевищує~24, але автору задачі невідомо, звідки береться с\'{а}ме~24, і\nolinebreak[2] чи\nolinebreak[2] більше взагалі не~може бути ні~при яких\nolinebreak[3] $V$,~$S$,\linebreak[2] чи\nolinebreak[3] такі приклади існують, але їх не~вдалося знайти. Тому й вирішено повідомити учасникам неочевидний факт, який чи\nolinebreak[3] то важко, чи\nolinebreak[3] то неможливо самостійно отримати під час туру, і який в~принципі може бути корисним: трійок-відповідей \emph{досить мало}.
Це,\nolinebreak[3] зокрема, означає, що не~варто перейматися високою ефективністю сортування чи якогось його аналога. А\nolinebreak[2] ще це\nolinebreak[2] дозволяє використати не~дуже ефективний, зате простий спосіб вирішення тієї проблеми, що є\nolinebreak[2] ситуації, коли трійка з усіма різними числами $(a,b,c)$ має бути виведена як шість різних трійок $(a,b,c)$,
$(a,c,b)$,
$(b,a,c)$,
$(b,c,a)$,
$(c,a,b)$,
$(c,b,a)$,\linebreak[2] 
є\nolinebreak[2] ситуації, коли $a\dib{{=}}b\dib{{=}}c$ і трійка має бути виведена лише раз,
і є\nolinebreak[2] ситуації, коли два числ\'{а} однакові й третє інше, і трійка має бути виведена як три різні трійки (причому, що с\'{а}ме треба переставляти, залежить від того, які два числ\'{а} однакові). Замість аналізу кожного з цих випадків окремо (де\nolinebreak[3] легко заплутатися!) можна завжди класти у масив всі шість перестановок, а\nolinebreak[3] після сортування першу трійку (якщо вона існує, тобто відповідь усієї задачі не~``\texttt{0~0~0}'') виводити завжди, а\nolinebreak[3] кожну подальшу трійку\nolinebreak[3] --- лише якщо вона не~дорівнює попередній. І\nolinebreak[3] хоча можна заявляти, що впихування у масив (чи\nolinebreak[3] в\nolinebreak[3] якийсь його аналог) шести трійок там, де частина з них однакові, поганеньке у плані ефективності, але будь-яка адекватна реалізація цього (простішого для написання!) підходу вкладатиметься в ліміт часу з~величезним запасом. Варто оптимізувати інші складові алгоритму, а~не~цю.

Хто знає множинні структури даних сучасних мов програмування (паскалівський \texttt{set} до них не~належить; мова про контейнер \texttt{set} мови\nolinebreak[3] C++, колекцію \texttt{TreeSet} мови Java чи\nolinebreak[3] \texttt{SortedSet} мови~C\#, тощо; тип \texttt{set} мови Python сюди підходить \emph{частково})\nolinebreak[3] --- може спробувати використати замість масиву якусь із них. Деякі з них можуть виконати відразу і сортування, і виключення повторів. Залежно від мови програмування та деталей реалізації, це може бути доступним відразу (порядок <<сортувати за першим елементом, а якщо вони однакові, то за другим>> може вважатися природнім і бути готовим; зокрема, це так у C++ при використанні \verb"set<vector<long long>>", де кожен такий \texttt{vector} є \mbox{3-еле}\-мент\-ним і подає одну трійку), або\nolinebreak[2] може потребув\'{а}ти задання власного компаратора, або\nolinebreak[2] може виявитися настільки незручним, що легше використати вищезгаданий підхід із сортуванням масиву.

\MyParagraph{У квадратного рівняння зазвичай буває два корені; як зрозуміти, який з них брати до уваги?}
Після фіксації $a$ перебором у циклі все\nolinebreak[3] ще лишилося справедливим твердження <<якщо трійка $(a, b, c)$ є розв'язком для потрібних $V$,~$S$, то й трійка $(a, c, b)$ теж>>. 
Том\'{у}, якби ми брали окремо один корінь~$b_1$, окремо інший~$b_2$, потім обчислювали на основі кожного з них 
${c_1\,{=}\,\frac{V}{ab_1}}$,
${c_2\,{=}\,\frac{V}{ab_2}}$,
то просто виходило~б 
те\nolinebreak[3] с\'{а}ме в\nolinebreak[3] різних порядках
(${b_1\,{=}\,c_2}$,
${b_1\,{=}\,c_2}$).
Том\'{у} здається природнім розглядати лише один з коренів квадратного рівняння. Будь-який. Інший все\nolinebreak[3] одно буде отриманий як $c\,{=}\,\frac{V}{ab}$.
(Можна отримати підтвердження цього, співставивши смисл коефіцієнтів рівняння з теоремою Вієта.) 

\MyParagraph{А в чому відмінність між двома останніми блоками?}
При розв'язуванні вищезгаданого квадратного рівняння, доводиться використати обчислення в типі \verb"double" чи аналогічному; через це, можуть виникати похибки (див.\nolinebreak[3] також стор.~\pageref{text:floating-point-error-in-0.3}), й ці похибки можуть бути досить великими, щоб, навіть коли теоретично-правильний-при-відсутності-похибок результат цілий, обчислення давало щось не~те. Передостанній блок тестів максимально уникає таких ситуацій: тести підбиралися так, щоб прості більш-менш адекватні способи боротьби з цією проблемою (як-то заокруглення до \emph{найближчого} цілого через \texttt{round} і подальша перевірка, чи\nolinebreak[3] справді знайдені при розв'язуванні квадратного рівняння\nolinebreak[3] \texttt{b},~\texttt{c}, разом з зафіксованим у\nolinebreak[3] циклі~\texttt{a}, задовольняють умови ${a\,{\cdot}\,b\,{\cdot}\,c}\dibbb{{=}}V$ та ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)\dibbb{{=}}S$) працювали й давали правильний результат. Останній блок, навпаки, провокує такі ситуації; зокрема, спеціально підбиралися такі значення, де обчислення за очевидною формулою створює \emph{великі} похибки (такі, що навіть заокруглення \texttt{round} дає не~те ціле число, яке мало~би бути, якби не~було похибок), тощо.

Це\nolinebreak[3] може здатися жахливим (як\nolinebreak[3] взагалі щось зробити в\nolinebreak[3] ситуації, коли неправильно працюють стандартні засоби?!). Але все не~так погано. Є\nolinebreak[3] чимало різних способів нівелювати проблему похибок. 

% % % застосуємо замість розв'язування квадратного рівняння за класичною формулою через дискримінант щось зовсім інше, наприклад, розв'язування бінарним пошуком. 
Наприклад, так: оскільки все\nolinebreak[3] ще досить розглядати $b\,{\<}\,c$ (звідки випливає $b^2\dibbb{{\<}}{bc}\dibbb{{=}}\frac{V}{a}\dibbb{{\<}}10^{18}$, отже ${b\,{\<}\,10^9}$), можна бути більш-менш упевненим (якщо, звісно, мати уявлення про діапазон можливих похибок у стандартних типах даних), що навіть якщо в такому $b$ є похибка, вона не~перевищує кілька одиниць; тому, виконаємо перевірку, чи $\frac{V}{a}$ кратне~$b$, і якщо так, то обчислення $c\,{=}\,\frac{V}{ab}$ та перевірку, чи ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)\dibbb{{=}}S$, не~лише для $b'$, знайденого за формулою меншого з коренів квадратного рівняння, а також і для недалеких (наприклад, для всіх $b$ з проміжку ${\max(a, b'\,{-}\,10)}\dibbb{{\<}}b\dibbb{{\<}}{b'\,{+}\,10}$). Правда, в комплекті з таким прийомом доводиться також вжити ще один прийом: якщо обчислений дискримінат виходить від'ємним, але близьким до нуля\nolinebreak[3] --- варто припустити, що то похибка й насправді він повинен бути рівно~0, і спробувати розв'язати рівняння з цією поправкою. Зайві розв'язки при цьому не~потраплять у відповідь, бо все'дно треба робити перевірку, чи\nolinebreak[2] $V\isdiv(ab)$, обчислення $c\,{=}\,\frac{V}{ab}$ та перевірку, чи\nolinebreak[2] ${2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)\dibbb{{=}}S$. 
% % % Або, можна помітити, що для цілочисельності всіх трьох розмірів $a$, $b$, $c$ необхідно, щоб усі коефіцієнти рівняння 
% % % ${a\cdot b^2}\dibbb{{+}}\bigl({\frac{V}{a}\,{-}\,\frac{S}{2}}\bigr)\cdot b\dibbb{{+}}V\dibbb{{=}}0$ були кратні~$a$ (з\nolinebreak[3] $V\,{=}\,abc$ випливає, що при цілих $b$ та\nolinebreak[3] $c$ $\frac{V}{a}$ є цілим; з\nolinebreak[3] $S\dibbb{{=}}{2\,{\cdot}\bigl(a\,{\cdot}\,b}\dibbb{{+}}{b\,{\cdot}\,c}\dibbb{{+}}{c\,{\cdot}\,a}\bigr)$ випливає, що при цілих $a$, $b$ та\nolinebreak[3] $c$ значення $S$ мусить бути п\'{а}рним (якщо не~так, можна зразу обривати й виводити ``\texttt{0~0~0}'')), тому можна, крім вже заг
% % % \ContinueHere
 % % % перетворити його до вигляду ${b^2}\dibbb{{+}}\frac{V/a-S/2}{a}b\dibbb{{+}}\frac{V}{a}\dibbb{{=}}0$
% % % Або, наприклад, перевіримо самі крайні випадки <<паралелепіпед має розміри ${1\times1\times{}V}$>> та <<$\sqrt[3]{V}$ цілий, і\nolinebreak[3] паралелепіпед має розміри $\sqrt[3]{V}\times\sqrt[3]{V}\times\sqrt[3]{V}$>> (с\'{а}ме вони найбільш чутливі до впливу похибок); для інших випадків, поділимо , й будемо підставляти у формули квадратного рівняння вже ці зменшені коефіцієнти, що зменшить вплив похибок.
% % % Перевірено, що \emph{кожен} з цих прийомів (взятий окремо; іншими словами, будь-який один з них) працює на останньому блоці тестів (правда, щодо останнього (і~лише його!) нема доведення його правильності, але від учасників олімпіади з~програмування доведень не~питають). Ще,\nolinebreak[3] тут в~принципі може бути корисною Крім того, якщо помітити, що всі коефіцієнти кратні~$a$ й розглядати квадратне рівняння 

Або, наприклад, так (цей спосіб трохи складніший, зате в ньому все краще з математичним обґрунтуванням).
Потрібно знайти розв'язок рівняння $a\cdot b^2 \dibbb{{+}} {\bigl(\frac{V}{a}-\frac{S}{2}\bigr)\cdot b} \dibbb{{+}} V \dibbb{{=}} 0$. Розглянемо його як функцію $f(b)\dibbb{{=}}a\cdot b^2 \dibbb{{+}} {\bigl(\frac{V}{a}-\frac{S}{2}\bigr)\cdot b} \dibbb{{+}} V$; це квадратний тричлен, парабола гілками догори, мінімум у точці $b^{*}\dibbb{{=}}\frac{\frac{S}{2}-\frac{V}{a}}{2a}$. Корінь~$b_1$ (такий, що ${f(b_1)\,{=}\,0}$) існує й задовольняє нашому бажаному співвідношенню $a\dib{{\<}}b_1\dib{{\<}}c_1\dib{{=}}\frac{V}{a\cdot{}b_1}$ тоді й тільки тоді ${b^{*}\,{\>}\,a}$, ${f(a)\,{\>}\,0}$ та ${f(b^{*})\,{\<}\,0}$; як\nolinebreak[3] відомо, на проміжку лівіше вершини парабола (гілками догори) монотонно спадає, тому можна застосувати бінарний пошук (почати з проміжку від\nolinebreak[2] $a$ до\nolinebreak[3] $b^{*}$ (\texttt{left:=}$a$; \texttt{right:=}$b^{*}$), потім багатократно бр\'{а}ти середину проміжку \texttt{m:=}$\frac{\texttt{left}+\texttt{right}}{2}$, і, залежно від того, 
чи\nolinebreak[3] ${f(m)\,{=}\,0}$,
чи\nolinebreak[3] ${f(m)\,{<}\,0}$, 
чи\nolinebreak[3] ${f(m)\,{>}\,0}$
приймати рішення, 
чи\nolinebreak[2] якраз вже знайшли корінь, 
чи\nolinebreak[3] можна відкинути всю праву половину (\texttt{right:=}$m$), 
чи\nolinebreak[3] можна відкинути всю ліву половину (\texttt{left:=}$m$);  
детальніше про бінпошук, зокрема й про застосування його до розв'язування рівнянь, можна знайти в багатьох різних джерелах у літературі чи Інтернеті).
%%% ; одним із багатьох можливих джерел є стаття, посилання на яку викладене у змаганні $\No\,$53 <<Дорішування теми ``Бiнарний та тернарний пошуки'' Школи Бобра \mbox{(23.10.2016)}>>)
Звісно, сам\nolinebreak[3] по\nolinebreak[3] собі факт використання бінпошуку замість формули розв'язування квадратного рівняння ще\nolinebreak[3] не\nolinebreak[3] гарантує, що всі похибки щезнуть\nolinebreak[3] --- бінпошук можна написати так, що похибки його перепаскудять і він даватиме неправильний результат. Але можна написати й так, що результат буде гарантовано правильним. Наприклад, постійно підтримувати 
\texttt{left},
\texttt{right} та
\texttt{m} цілими (нам же все'дно потрібні цілі розв'язки), але при цьому 
спочатку обчислювати $f(\texttt{m})$ у \texttt{double}, і\nolinebreak[3] якщо результат великий за модулем, то приймати рішення на основі цього, а\nolinebreak[3] якщо більш-менш близький до~0 (і\nolinebreak[3] тому нема ситуації, коли в цілочисельному типі стається переповнення й результат дуже далекий від правильного), то обчислити ще раз вже у 64-бітовому цілому типі й не~мати похибок. 
Якщо мова програмування має вбудовану <<довгу арифметику>> (здатність працювати з точними, без\nolinebreak[3] похибок, цілими числами потенційно нескінч\'{е}нної довжин\'{и}; в\nolinebreak[3] особливо виграшному становищі тут Python~3, бо там не~просто є <<довга арифметика>>, там перемикання на неї відбувається автоматично, без вказівок з боку програміста), це полегшує роботу, бо тоді досить працювати лише в <<довгій арифметиці>> замість двоступінчастого монстру з двох різних типів.


Є\nolinebreak[3] й\nolinebreak[3] кілька ще\nolinebreak[3] інших способів обійти проблему похибок; не~всі з них мають математично строгі доведення, але ж учасники мають можливість спробувати здати кілька різних розв'язків, а\nolinebreak[3] доведень у них (вас) не~питають. Тому, хоча~б якось здати (<<пропхнути>>) на повні бали цілком можливо. А,~щоб здати на 300~з~350, не~треба взагалі нічого, крім циклів\&розгалужень, сортувань (будь-якого рівня ефективності), ну і цілком стандартних знань шкільного курсу алгебри.


% % % Тобто, досить легке поєднання \texttt{for} та \texttt{if} дає змогу відібрати лише такі $a$, для яких $\frac{V}{a}\m{=}\,bc$ є цілим. 