~\mbox{}~$\phantom{x}$~

\vspace{-0.5\baselineskip}

\Tutorial
На основних можливих проблемах, які \emph{могли~б} виникнути, звернуто увагу (звісно, без пояснень) у~примітці наприкінці умови.

Зокрема, не~можна будувати кожен наступний квадрат-відповідь на~основі попереднього ква\-д\-ра\-ту-від\-по\-віді, бо просто заокруглене середнє і заокруглене середнє заокруглених середніх не~завжди дорівнюють одн\'{е} \'{о}дному. 
Зокрема, це проявляється на згаданому <<першому числі передостаннього рядка вiдповiдi першого тесту>>: $(1\dib{{+}}2\dib{{+}}3\dib{{+}}2\dibbb{{+}}
2\dib{{+}}1\dib{{+}}2\dib{{+}}3\dibbb{{+}}
3\dib{{+}}2\dib{{+}}1\dib{{+}}2\dibbb{{+}}
2\dib{{+}}3\dib{{+}}2\dib{{+}}{1)\,/\,16}\dibbb{{=}}{32\,/\,16}\dibbb{{=}}2$, % (ще~й\nolinebreak[2] у~точності, але це несуттєво), 
тоді як при обчисленнях окремих квадратів ${2\,{\*}\,2}$ виходить 
$(1\dib{{+}}2\dib{{+}}2\dib{{+}}{1)\,/\,4}\dibbb{{=}}\frac{6}{4}\dib{{\approx}}2$,\hspace{0.125em plus 0.5em}
$(3\dib{{+}}2\dib{{+}}2\dib{{+}}{3)\,/\,4}\dibbb{{=}}\frac{10}{4}\dib{{\approx}}3$,\hspace{0.125em plus 0.5em}
$(3\dib{{+}}2\dib{{+}}2\dib{{+}}{3)\,/\,4}\dibbb{{=}}\frac{10}{4}\dib{{\approx}}3$,\hspace{0.125em plus 0.5em}
$(1\dib{{+}}2\dib{{+}}2\dib{{+}}{1)\,/\,4}\dibbb{{=}}\frac{6}{4}\dib{{\approx}}2$,\hspace{0.125em plus 0.5em}
після чого спроба побудувати результат квадрату ${4\,{\*}\,4}$ на основі квадратів ${2\,{\*}\,2}$ дає
$(2\dib{{+}}3\dib{{+}}3\dib{{+}}{2)\,/\,4}\dibbb{{=}}\frac{10}{4}\dib{{\approx}}3$.

Є~щонайменше два способи вирішення цієї проблеми. 

(А)~Діяти згідно зі словесним формулюванням з\nolinebreak[3] умови, тобто справді рахувати суми квадратів розмірами ${2\,{\*}\,2}$ й ділити на~4, потім суми квадратів розмірами ${4\,{\*}\,4}$ й ділити на~16, і так далі. 
\ifnum\number\month > 10 \TODO % Приклад реалізації такої ідеї див. \ideOne{.....}
\fi

\myflfigaw{\hspace*{-1em}$
\left(
\textnormal{\begin{tiny}
\begin{tabular}{@{}c@{\,\,\,}c|c@{\,\,\,}c|c@{\,\,\,}c|c@{\,\,\,}c@{}}
1 & 2 & 3 & 2 & 1 & 2 & 5 & 1 \\
2 & 1 & 2 & 3 & 0 & 3 & 9 & 1 \\\hline
3 & 2 & 1 & 2 & 2 & 9 & 7 & 5 \\
2 & 3 & 2 & 1 & 8 & 7 & 7 & 8 \\\hline
1 & 5 & 3 & 0 & 3 & 5 & 9 & 5 \\
9 & 6 & 9 & 5 & 4 & 6 & 6 & 5 \\\hline
2 & 4 & 4 & 3 & 8 & 4 & 5 & 4 \\
1 & 8 & 4 & 5 & 9 & 4 & 8 & 4 \\
\end{tabular}
\end{tiny}}
\right)
\Rightarrow
\left(
\textnormal{\begin{small}\begin{tabular}{@{}c@{\,\,\,}c|c@{\,\,\,}c@{}}
 6 & 10 &  6 & 16 \\
10 &  6 & 26 & 27 \\\hline
21 & 17 & 18 & 25 \\
15 & 16 & 25 & 21 \\
\end{tabular}\end{small}}
\right)
\Rightarrow
\left(
\textnormal{\begin{tabular}{@{}c@{\,\,\,}c@{}}
32 & 75 \\
69 & 89 \\
\end{tabular}}
\right)
$}
(Б)~Можна (і,\nolinebreak[3] мабуть, простіше) формувати з квадрата розмірами ${N\,{\*}\,N}$ квадрат розмірами ${\frac{N}{2}\,{\*}\,\frac{N}{2}}$, де кожен елемент меншого квадрату є \emph{сумою} відповідних чотирьох елементів початкового квадрату, а~ділення й округлення робити безпосередньо перед виведенням; далі рахувати ${\frac{N}{4}\,{\*}\,\frac{N}{4}}$ \emph{сум} відповідних чотирьох елементів квадрату розмірами ${\frac{N}{2}\,{\*}\,\frac{N}{2}}$, і так далі.
%
На\nolinebreak[3] відміну від знаходження заокруглених середніх, для додавання виконуються комутативність та асоціативність (вони\nolinebreak[3] ж переставний та сполучний закони), тож суми сум гарантовано є правильними сумами квадратів ${4\,{\*}\,4}$, наступні суми\nolinebreak[3] --- правильними сумами квадратів ${8\,{\*}\,8}$, \mbox{тощо}.

Перевага цього підходу~(Б) над попереднім підходом~(А)\nolinebreak[3] --- 
% не~треба писати цикли 
не~треба циклів
проходження квадрата ${2^j\,{\*}\,2^j}$ при різних~$j$, досить значно простішого коду \texttt{\mbox{arrNew[i][j]} = \mbox{arrOld[2*i][2*j]} + \mbox{arrOld[2*i][2*j+1]} + \mbox{arrOld[2*i+1][2*j]} + \mbox{arrOld[2*i+1][2*j+1]}} (при нумерації масивів з~0; при нумерації з~1 такий підрахунок набуває вигляду \texttt{\mbox{arrNew[i][j]} := \mbox{arrOld[2*i-1][2*j-1]} + \mbox{arrOld[2*i-1][2*j]} + \mbox{arrOld[2*i][2*j-1]} + \mbox{arrOld[2*i][2*j]}}), узятого у три цикли: два внутрішні перебирають індекси чергового, удвічі зменшеного відносно попереднього, квадрата, зовнішній перебирає розмір квадрата.

Тобто, досі описано вже два способи отримати ті 40$\,$\%~балів (що\nolinebreak[3] не~так мало), які призначені за блоки 3,~6,\nolinebreak[3] 9,~11, в~яких зображення сіре (\texttt{gray}).
Що\nolinebreak[3] стосується варіанту ``\texttt{rgb}'', то ускладнення більш технічні, ніж ідейні (олімпіада, кінець кінцем, <<з~інформатики (програмування)>>, а~не~математики). Просто треба грамотно читати вхідні дані (чи~то <<розбираючи>> рядки (\texttt{string}) на окремі двозначні шістнадцяткові ч\'{и}сла, чи~то <<збираючи>> ці двозначні шістнадцяткові ч\'{и}сла з окремих символів (\texttt{char})), виконати такі самі, як у сірому варіанті, дії для кожного з трьох каналів R,\nolinebreak[3] G\nolinebreak[3] та~B, а\nolinebreak[3] наприкінці зробити зворотнє перетворення (чи~то сформувати для кожного пікселя семисимвольний рядок, сформувавши його зі знайдених R-, G- та B-значень, чи~то розділити знайдені R-, G- та B-значення на символи, що~є окремими шістнадцятковими цифрами, й вивести для кожного пікселя потрібну послідовність цих окремих символів).

Більшість мов програмування мають вбудовані засоби перетворення між рядковим та чисельним поданнями. Тут ситуація дещо ускладнюється тим, що потрібно вводити/виводити \emph{шістнадцяткові} ч\'{и}сла, причому завжди двозначні (для\nolinebreak[2] менших~16\nolinebreak[3] --- з додатковим нулем спереду) та обов'язково з мал\'{и}ми буквами для\nolinebreak[2] цифр\nolinebreak[3] \mbox{\texttt{a}--\texttt{f}}. Більшість сучасних мов програмування дозволяє все\nolinebreak[3] це налаштувати у викликах стандартних функцій. Щоправда, далеко не~всі пам'ятають такі деталі, тож важливим стає питання, як і де їх швидко подивитися; враховуючи, що на олімпіадах взагалі-то має бути омежений доступ до Інтернету, корисно навчитися користуватися, крім пошуку в~Інтернеті, також підказками середовищ прорамування та вбудованою документацією (help-ом).

Можна також самостійно написати функції, які виконуватимуть потрібний вузький частковий випадок перетворень (в~обох напрямках) між внутрішнім чисельним поданням і рядковим шістнадцятковим записом. У~професійному програмуванні такі реалізації давно реалізованого, як~правило, \underline{не}~вітаються і вважаються <<написанням велосипедів>>. Але навіть у~професійному програмуванні бувають виключення з цього правила; якщо ж ситуація посилюється тим, що на олімпіаді сильно обмежені можливості дивитися документацію, то цілком можна й <<написати велосипед>>.

Насамкінець, що робити з тим, що на вхід одній і тій самій програмі може бути подано як ``\texttt{gray}'', так і ``\texttt{rgb}''? Мабуть, прочитавши перший рядок, тут же робити розгалуження вигляду \texttt{if mode='gray' then DoAllGray else DoAllRGB}, де ``\texttt{DoAllGray}'' та ``\texttt{DoAllRGB}''\nolinebreak[3] --- самостійно написані підпрограми, які розв'язують задачу (включно з читанням решти, крім першого рядка, вхідних даних, та виведенням результатів) одна для сірого випадку, інша для~RGB. Пізніше сюди будуть дописані також приклади розв'язків, у яких такого дублювання коду практично нема (суто алгоритмічна частина написана все-таки один раз, а відмінності в діях для ``\texttt{gray}'' та ``\texttt{rgb}'' зроблені за допомогою перевантаження операцій та/або поліморфізму); але в цій задачі це не~дуже доцільно, а~засоби доводиться використовувати досить складн\'{і}. 
