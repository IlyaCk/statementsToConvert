\Tutorial
Смисл окремого блоку~1 (розміри до~4) 
хіба~що в~тому, що для нього можна порахувати все вручну і понаписувати у~програму 
готові відповіді (вибираючи потрібну \texttt{if}-ами). 
Якщо ж робити реальний алгоритмічний розв'язок, 
блок~2 (розміри до~42) нічим не~складніший за блок~1.

Аналізуючи наведений у~прикладі повний перелік усіх прямокутників,
можна побачити, що 
у~перших трьох використовується діапазон $y$-коор\-ди\-нат від~0 до~1,
у~наступних трьох від~0 до~2 і в~останніх трьох від~1 до~2.
Аналогічно, всер\'{е}дині кожної з цих трійок 
перший прямокутник має діапазон $x$-коор\-ди\-нат від~0 до~1,
др\'{у}гий (кожної трійки)\nolinebreak[3] --- від~0 до~2,
третій\nolinebreak[3] --- від~1 до~2.

\MyParagraph{Розв'язок для блоків 1--2.} 
Можна продовжити аналіз того~ж переліку, і~помітити, 
що <<від~0\nolinebreak[2] до~1>> та <<від~0\nolinebreak[2] до~2>>
являють собою початок~0 і всі можливі (обидва) кінці,
<<від~1\nolinebreak[2] до~2>>\nolinebreak[3] --- 
початок~1 і єдиний можливий кінець. 
Тобто, всі можливі діапазони окремо взятої координати можна перебрати
двома вкладеними циклами, де зовнішній перебирає можливі початки, 
внутрішній\nolinebreak[3] --- можливі кінці. 
Неважко переконатися, що це~підтверджується також і при більших розмірах листочка.

{

\def\tabbb{\hspace*{1em}}

\myflfigaw{\ifAfour\hspace*{-2mm}\begin{minipage}{15.5em}\else\begin{minipage}{15em}\fi\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}read(xsz, ysz);\\
res:=0;\\
for ymin:=0 to ysz-1 do\\
\tabbb{}for ymax:=ymin+1 to ysz do\\
\tabbb\tabbb{}for xmin:=0 to xsz-1 do\\
\tabbb\tabbb\tabbb{}for xmax:=xmin+1 to xsz do\\
\tabbb\tabbb\tabbb\tabbb{}res:=res+1;\end{alltt}\end{small}\end{minipage}}

Що можна перетворити у~перебір усіх можливих 
прямокутників 
чотирма вкладеними циклами, наведеними праворуч: 
перші два цикли перебирають початки та кінці діапазонів $y$-коор\-ди\-нати,
наступні (вкладені) два\nolinebreak[3] --- аналогічно для $x$-коор\-ди\-нати.

Тільки цей спосіб, хоч і правильний, не~ефективний. 
Такі цикли працюють надто довго не~лише для блоку~4 (розміри до~$10^9$),
але і для блоку~3 (розміри до~54321). 
Причому, питають-то лише кількість, а~не~самі прямокутники!
Отже, насправді не~варто будувати (перебирати) кожен прямокутник окремо.

}

\MyParagraph{Аналіз засобами комбінаторики.} Важливе спостереження $\No\,1$:
раз кожен можливий діапазон $y$-коор\-ди\-нат можна поєднувати з 
кожним можливим діапазоном $x$-коор\-ди\-нат\nolinebreak[3] --- 
достатньо порахувати кількості можливих діапазонів для кожної з~координат окремо,
й~перемножити ці кількості.
Це\nolinebreak[3] просто-таки еталонний приклад так званого \emph{правила добутку} комбінаторики.

Важливе спостереження $\No\,2$: % всі можливі 
діапазони однієї окремо взятої координати 
є парами чисел від~0 до~максимального значення (розміру за~цією координатою).
Причому, це пари різних елементів (при однакових, прямокутник вироджується у~відрізок чи~точку, 
а~з~прикладу видно, що це~не~рахується); 
причому, ці пари не~впорядковані (обмін місцями, як-то (0;2)$\leftrightarrow$(2;0), не~утворює нового діапазону).
Отже, ці пари являють собою сполучення (вони~ж сполуки, вони~ж комбінації) без повторень по~2,
і їхню кількість можна знайти за формулою 
$C_{s+1}^{2}\dib{{=}}\frac{(s+1)(s+1-1)}{1\cdot2}\dib{{=}}\frac{(s+1)s}{2}$ 
(де\nolinebreak[3] $s$\nolinebreak[3] --- розмір за відповідною координатою; 
${s\,{+}\,1}$, а~не~$s$, бо до можливих значень координати включаються і~0, і~$s$).

Отже, відповіддю задачі є $\displaystyle\frac{x(x+1)y(y+1)}{4}$ 
(де\nolinebreak[3] $x$ та\nolinebreak[3] $y$\nolinebreak[3] --- вхідні дані).

\MyParagraph{А~в~чому тоді відмінність між блоками тестів 3 та~4?}  Частково\nolinebreak[3] --- 
для блоку~3 ще~проходять 
% деякі з розв'язків, 
деякі розв'язки, 
де частина з~цих % математичних 
спостережень зроблена, а\nolinebreak[3] частина\nolinebreak[3] ні 
(наприклад, позбулися вкладених циклів, 
але, не~зумівши перетворити % все 
у~пряму аналітичну формулу, один цикл лишили).

Але це не~все. 
Підставивши у~формулу % максимальні можливі значення
максимальні значення 
$x\dib{{=}}y\dib{{=}}10^9$,
легко бачити, що при них відповідь перевищуватиме $\frac{1}{4}\cdot10^{36}$, 
що за~межами % всіх 
стандартних типів даних.
Так що для отримання повних балів % за цю задачу 
треба використати 
т.~зв. \emph{довгу арифметику}\nolinebreak[3] --- 
подавати ч\'{и}сла, наприклад, масивами цифр 
і виконувати арифметичні дії не~стандартними процесорними командами,
а~виконанням алгоритмів, подібних до % шкільного алгоритму 
множення у~стовпчик.
Правда, тут не обов'язково писати повноцінну довгу арифметку:
окремо взяті $\frac{x(x+1)}{2}$ та $\frac{y(y+1)}{2}$ цілком можна обчислити у стандартному 64-бітовому типі, тож лишається тільки перетворити один з цих добутків у довге число 
й помножити його на 64-бітове 
(єдина дія довгої арифметики).
Приклад саме такої програми (мовою Pascal) див. \IdeOne{ug49QD}.

При бажанні можна обійтися без власноручного написання 
навіть і окремих операцій довгої арифметики.
У~переліку мов програмування є Python, 
в~якому довга арифметика вбудована і викликається автоматично,
а~також Java, де довга арифметика не~настільки зручна, 
але~є (клас \texttt{BigInteger}). % , і~користуватися нею все~ж легше, ніж писати свою.
(C\# теж має клас \texttt{BigInteger}, але там усе сумніше, бо засоби, якими C\#-\texttt{BigInteger} підключається на локальному Windows-комп'ютері, не~працюють на Linux-сервері ejudge, і авторам збірника невідомо ні як їх підключити там, ні, навіть, чи~можливо це взагалі.)

{
\def\rectsLongAriPythonPhrase{Розв'язок мовою Python наведено праворуч. 
Це\nolinebreak[3] повний текст повнобального розв'язку всієї задачі.
Разів так у 15 коротший, ніж мовою Pascal.}
\def\rectsLongAriPythonCode{\mbox{\ifAfour\begin{minipage}{19.5em}\else\begin{minipage}{18em}\fi\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}x, y = map(int, input().strip().split())\\
print((x*(x+1)*y*(y+1))//4)\end{alltt}\end{small}\end{minipage}}}

\ifAfour
\mytextandpicture{\rectsLongAriPythonPhrase}{\rectsLongAriPythonCode}
\else
\myflfigaw{\raisebox{-9pt}[0pt][0pt]{\rectsLongAriPythonCode}}
\rectsLongAriPythonPhrase
\fi

}

Можна заявити, ніби це порушує права учасників, що пишуть іншими мовами.
Але:
(1)~Ніхто нікому не~забороняв вивчити і використати Python.
Хто більше знає\nolinebreak[3] --- має більше шансів на перемогу, що тут несправедливого?
(2)~Довгу арифметику \emph{можна} написати \emph{будь-якою} з дозволених мов програмування
(зокрема, див.~посилання вище).
Питання лише в~тому, чи це зручно й легко, чи~дещо довше й важче.
Ситуації, коли мовою~C++ можна використати бібліотечну функцію, 
а~мовою Pascal доводиться реалізовувати алгоритм самому, 
вже згадувалися у~цьому збірнику
% щонайменше разів із десять; 
дуже багато разів;
ну, а~тут виграш має інша мова.
(3)~Довга арифметика потрібна \emph{лише} у останньому \mbox{4-му} блоці тестів.

Мова Python \emph{не}~є універсально-найкращою для олімпіад.
Просто % тут і з\'{а}раз 
розглянута така задача, що \emph{для неї} Python має велику перевагу. 
У~багатьох інших ситуаціях Python програ\'{є} 
(зокрема, том\'{у}, що програми мовою Python виконуються помітно повільніше, ніж мовами С/С++ чи~Pascal).
Цікавою є, зокрема, ситуація з % мовою Python та 
задачею <<Остання ненульова цифра>> (стор.~\pageref{text:201819-2-C-start}--\pageref{text:201819-2-C-finish}), в якій водночас і суперзручна довга арифметика мови Python дозволяє легко отримати 60\% балів за те, що іншими мовами набирає % лише 
20--34\% балів, і набрати мовою Python більше, ніж 80\% балів, значно важче, ніж іншими мовами.
