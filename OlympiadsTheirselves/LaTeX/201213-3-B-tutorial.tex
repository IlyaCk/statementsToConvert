\Tutorial	Завдяки гарантії, що ч\'{и}сла ненульові, <<змінюється знак>> можна виражати досить простим виразом \texttt{(\mbox{(a[i-1]>0)} and \mbox{(a[i]<0)}) or (\mbox{(a[i-1]<0)} and \mbox{(a[i]>0)})}, або ще простішим \verb"a[i-1]*a[i] < 0". Лишається тільки перевірити цю умову для всіх пар сусідніх елементів і підрахувати кількість разів, коли ця умова дала результат \texttt{true}. Мовою Pascal, при нумерації масиву\nolinebreak[2] з~1, цикл матиме вигляд \texttt{for i:=2~to~n do~...}; C-подібними мовами, при нумерації\nolinebreak[2] з~0, \texttt{for(int\nolinebreak[3] i=1; i<n; i++)~...}; мовою Python, %(байдуже, 2~чи~3), 
теж при нумерації\nolinebreak[2] з~0, \texttt{for i in \mbox{range(1,n)}:~...}.

Якби гарантії відсутності нулів не~було, задача була~би складнішою. По-перше, треба було~б чи то знайти в умові задачі, чи то взнати в журі чітке означення зміни знаку: \mbox{``--2, 0, +1''}\nolinebreak[3] --- це одна зміна знаку чи дві? А~\mbox{``--2, 0, 0, 0, +1''}? \mbox{``+2, 0, +3''} містить зміну знаку чи~ні? А~\mbox{``--2, 0, --3''}? А~як\nolinebreak[2] бути з нулями на початку чи наприкінці? По-друге, треба було~б переглядати послідовність, постійно перебуваючи в одному зі станів <<послідовність лише починається, чисел ще~не~було>>, <<від самого початку послідовності були лише нулі>>, <<останнім був нуль чи кілька нулів, перед ними додатне число>>, <<останнім був нуль чи кілька нулів, перед ними від'ємне число>>, <<останнім було додатне число>>, <<останнім було від'ємне число>> (перелік приблизний, точний може залежати від уточнень, згаданих у <<по-перше>>), та приймаючи рішення щодо додавання чи не~додавання нової зміни знаку згідно стану та значення наступного числ\'{а}.
