\Tutorial	
Головне при розв'язуванні цієї задачі\nolinebreak[3] --- не\nolinebreak[3] перестаратися й не\nolinebreak[3] почати писати <<чесні>> перевірки перетинів. Такі перевірки могли\nolinebreak[3] б бути доречними при більших розмірах сітки та меншій кількості відрізків ламаної. А\nolinebreak[3] при заданій кількості, відомі автору цього розбору оптимізації перебору всіх можливих перетинів не~вкладаються у\nolinebreak[3] обмеження\nolinebreak[2] часу.

У цій задачі краще помітити такі факти: 

\begin{enumerate}
\item
% % % (1)~%
Хоча окремо взятий відрізок (ланка ламаної) може мати довжину аж~5000, а\nolinebreak[3] кількість відрізків може сягати мільйона, сумарна довжина відрізків обмежується не\nolinebreak[2] $5000\dib{{\*}}10^6\dibbb{{=}}{5\,{\cdot}\,10^9}$, а\nolinebreak[3] тим, що раз відрізки лише горизонтальні й вертикальні, а\nolinebreak[3] накладання заборонені, то кожна з $5000{\*}5000$ вершин сітки може бути задіяна щонайбільше двічі, і сума довжин усіх відрізків$\dib{{<}}$50~млн. 
\item
% \par
% % % (2)~%
$5000{\*}5000\dib{{=}}25\textnormal{~млн}$\nolinebreak[3] --- дуже багато для людини, але для комп'ютера\nolinebreak[3] --- не\nolinebreak[3] так і багато. Не\nolinebreak[3] лише у\nolinebreak[3] розрізі <<виконати 25~млн\nolinebreak[2] дій>>, а\nolinebreak[3] також і у\nolinebreak[3] розрізі <<тримати в\nolinebreak[3] пам'яті 25~млн\nolinebreak[2] елементів>>. (Але, щоб укластися в обмеження пам'яті, вони мусять бути 1- чи 2-байтовими!)
\end{enumerate}

\phantomsection\label{text:drawing-by-coords-in-graphics-password-problem}
Завдяки цьому, найдоречнішим (досить ефективним для с\'{а}ме цих обмежень і при цьому значно простішим за альтернативи) виявляється такий простий підхід: \textsl{<<завести масив $5000{\*}5000$, ініціалізувавши всі елементи нулями; ходити уздовж ліній, збільшуючи на~1 значення у комірках, відповідних пройденим вершинам сітки; відповіддю буде кількість комірок зі значенням~2>>}. Великий time\nolinebreak[2] \mbox{limit} 4~сек потрібен не\nolinebreak[3] стільки для роб\'{о}ти алгоритму, скільки для читання величезних вхідних даних. Приклад реалізації цього алгоритма\nolinebreak[3] --- \IdeOne{SlR8oV}.


