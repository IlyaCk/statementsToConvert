{

\def\tabbb{\hspace*{1em}}

\myflfigaw{\ifAfour\hspace*{-2mm}\begin{minipage}{14.25em}\else\begin{minipage}{13.5em}\fi\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}if curr < min\_val then begin\\
\tabbb{}min\_val := curr;\\
\tabbb{}min\_idx := i;\\
end;\\
if curr >= max\_val then begin\\
\tabbb{}max\_val := curr;\\
\tabbb{}max\_idx := i;\\
end;\end{alltt}\end{small}\end{minipage}}

\Tutorial
Тут досить акуратно внести дрібні зміни у стандартні (<<шкільні>>) алгоритми пошуку мінімуму й максимуму. 

Щоб знаходити \emph{перший} мінімум та \emph{останній} максимум, можна або запускати цикли у різних напрямках (один зліва направо, тобто від менших індексів до більших, інший навпаки), або для кожного поточного елемента діяти, як у коді праворуч (``\verb"<"''~для мінімуму та ``\verb">="''\nolinebreak[3] для максимуму).

Остат\'{о}чну відповідь можна виразити як \texttt{abs(max\_idx~-\nolinebreak[2] min\_idx)~-~1}: модуль, бо перший мінімум може бути як лівіше за останній максимум, так і правіше; мінус~1, бо, наприклад, для сусідніх елементів ця різниця дорівнює~1, а\nolinebreak[2] проміжних елементів між сусідніми нема\nolinebreak[2] (0~штук). 
Приклади реалізації див.\nolinebreak[2] \IdeOne{1wPo1q} та \IdeOne{b0AWG2} (обидві мовою Pascal, перша без масиву, др\'{у}га з масивом).

Можна використати й бібліотечні засоби пошуку мінімума та максимума, але навряд чи це буде простіше; наприклад, у \IdeOne{5mEczH} задача розв'язана через \verb"min_element" та \verb"max_element" 
% (бібліотека \texttt{algorithm} набору бібліотек STL мови~C++), 
(бібліотека \texttt{algorithm} з\nolinebreak[3] C++\nolinebreak[3] STL), 
і потреба знайти \emph{перший} мінімум та \emph{останній} максимум призводить до не~\mbox{дуже} очевидних різних ітераторів та різних перетворень їх у індекси.

}