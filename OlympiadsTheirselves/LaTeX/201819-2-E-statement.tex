\begin{problem}{Палички, інтерактивна гра}{Клавіатура (stdin)}{Екран (stdout)}{1 сек}{64 мегабайти}
\label{prob:201819-2-E-sticks-with-spec-moves-interactive}
%\label{prob:201819-oioi-C-sticks-simple-interactive}


\ifStatementOnly
Для цієї задачі (й~лише для неї) встановлене жорстке обмеження кількості спроб здачі: \begin{itshape}\begin{bfseries}не~більше 5 (п'яти) спроб на одного учасника\end{bfseries}\end{itshape}.
\fi

% % % Є одна купка, яка спочатку містить $N$ паличок.
% % % Двоє грають у таку гру.
% % % Спочатку перший гравець може забрати з купки або~1, або~2 палички.
% % % На~кожному подальшому ході кожен з гравців може забрати з купки будь-яку кількість паличок від~1 до подвоєної кількості, щойно забраної суперником (обидві межі включно).
% % % Ніяких інших варіантів ходу нема. 
% % % Ходять гравці по черзі, пропускати хід не~можна.
% % % Виграє той, хто забирає останню паличку (можливо, разом з деякими іншими).

Суть гри в точності та сама, що у попередній задачі.

Напишіть програму, яка інтерактивно гратиме за першого гравця. 

На початку, один раз, Ваша програма повинна прочитати одне ціле число в окремому рядку\nolinebreak[3] --- початкову кількість паличок $N$ ($2{\<}N{\<}12345$).
Потім вона повинна повторювати такий цикл:
\begin{enumerate}
\item\looseness=-1
Вивести єдине число в окремому рядку\nolinebreak[3] --- свій хід, тобто кількість паличок, які вона зараз забирає з купки.
На першому ході це повинно бути 1 або~2, на подальших\nolinebreak[2] --- ціле число від~1 до подвоєної кількості, щойно забраної про\-гра\-мою-суперницею, причому не~більше за поточну кількість паличок у купці. 
\item
Якщо після цього купка стає порожньою, 
% вивести рядок із фразою ``\texttt{I~won!}''
вивести окремим рядком фразу ``\texttt{I~won!}''
(без лапок, символ-у-символ згідно зразку) і завершити роботу.
\item
Прочитати хід програми-суперниці, тобто кількість паличок, які вона зараз забирає з~купки (єдине % ціле 
число, в окремому рядку).
Якщо Ваша програма правильно визначила, що гра % ще~
не~закінчилася і цей хід % взагалі 
відбудеться, то гарантовано, що він допустимий (%введене 
число є цілим від~1 до подвоєної кількості, щойно забраної Вашою програмою, і не~перевищує поточну кількість паличок у купці).
\item
Якщо після цього купка стає порожньою, 
вивести окремим рядком 
фразу ``\texttt{You~won...}''
(без\nolinebreak[3] лапок, символ-у-символ згідно зразку) і завершити роботу.
\end{enumerate}
Ці дії повинні повторюватися, 
доки\nolinebreak[3] якась із програм-гравців не~в\'{и}грає.
% доки\nolinebreak[3] не\nolinebreak[2] будуть забрані всі палички (тобто, \mbox{доки} якась із програм-гравців не~в\'{и}грає).
Програма-суперниця не~виводить фраз ``\texttt{I~won!}''\nolinebreak[2] / ``\texttt{You~won...}'' 
чи\nolinebreak[2] якихось їх аналогів.

Ця задача є інтерактивною: 
Ваша програма не~отримає всіх вхідних даних на~початку,
а~отримуватиме по~мірі виконання доуточнення, 
що залежатимуть від попередніх дій Вашої програми. 
Тим~не~менш, \begin{slshape}її перевірка буде
\underline{автоматичною}\end{slshape},
тому слід чітко дотримуватися формату спілкування з~програмою-суперницею.

Настійливо рекомендується, щоб Ваша програма після кожного свого виведення 
робила дію \verb"flush(output)"\nolinebreak[2] (Pascal), 
вона~ж \verb"cout.flush()"\nolinebreak[2] (C++), 
вона~ж \verb"fflush(stdout)"\nolinebreak[2] (C), 
вона~ж \verb"sys.stdout.flush()"\nolinebreak[2] (Python),
вона~ж \verb"System.out.flush()"\nolinebreak[2] (Java).
Це~істотно зменшує ризик, 
що~проміжна відповідь <<загубиться>> десь по~дорозі, 
не~дійшовши до програми-суперниці.

\Scoring
Тести оцінюються кожен окремо (без~блоків).
У\nolinebreak[3] \mbox{1-му}\nolinebreak[2] тесті\nolinebreak[2] ${N\,{=}\,3}$, 
у\nolinebreak[3] \mbox{2-му}\nolinebreak[2] ${N\,{=}\,5}$,
і ці тести не~приносять балів.
Решта тестів приносять однакові бали.
У\nolinebreak[3] 20\%\nolinebreak[3] тестів ${2\,{\<}\,N\,{\<}\,25}$ (${N\,{\neq}\,3}$, ${N\,{\neq}\,5}$), програма-суперниця ідеальна (не~робить помилок).
Ще\nolinebreak[3] у\nolinebreak[2] 20\%, ${100\,{<}\,N\,{\<}\,1234}$, суперниця ідеальна.
Ще\nolinebreak[3] у\nolinebreak[2] 20\%, ${1234\,{<}\,N\,{\<}\,12345}$, суперниця ідеальна.
Ще\nolinebreak[3] у\nolinebreak[2] 20\%, ${100\,{<}\,N\,{\<}\,1234}$, суперниці інші.
Ще\nolinebreak[3] у\nolinebreak[2] 20\%, ${1234\,{<}\,N\,{\<}\,12345}$, суперниці інші. 
%%
Ці\nolinebreak[3] інші програми-суперниці (їх\nolinebreak[3] кілька різних) роблять ходи, де гарантовано дотримані вимоги <<забирати лише від~1 палички до подвоєної щойно забраної кількості>> та <<забирати не~більше паличок, ніж~є у~купці>>, але\nolinebreak[2] дотримуються кожна власних уявлень, як\nolinebreak[2] треба грати, частенько вибираючи не~найкра\-щий з допустимих ходів.

Буде оцінюватися і~вміння Вашої програми виграти там, де це точно можливо,
і~вміння Вашої програми достойно, згідно правил, програти, де виграш неможливий, 
і~вміння Вашої програми скористатися (теж\nolinebreak[2] згідно правил) помилками чи іншими неадекватностями програми-суперниці, якщо такі будуть.
Якщо Ваша програма прогр\'{а}є там, де могла виграти, зате зробить це з дотриманням усіх вимог,
відповідний тест буде оцінено на\nolinebreak[2] 1~бал~з~5.
За\nolinebreak[3] будь-яке порушення правил гри з\nolinebreak[3] боку Вашої програми, відповідний тест буде оцінено на~0~балів.

{
\Examples

\ifAfour
\vspace{-\baselineskip}
\fi

\makeTableLongtrue
\noindent\begin{exampleThreeWithSpecNameColTwoAndLineStretch}{5em}{5em}{\ifAfour 11.5cm\else 10cm\fi}{Результати}{Примітки}{-5pt}{-2pt}{0.625}
\exmp{3
~
2}{~
1
~
You won...}{\noindent\ifAfour\begin{minipage}[t]{11.5cm}\else\begin{minipage}[t]{10cm}\fi
\setstretch{0.875}
\ifAfour
У купці спочатку 3 палички. Ваша програма забирає одну, лишається дві; програма-суперниця забирає обидві й виграє.
\else
У купці спочатку 3 палички.
Ваша програма забирає одну, лишається дві;
програма-суперниця забирає обидві й виграє.
\fi
\end{minipage}}%
\exmp{3
~
1}{~
2
~
You won...}{\noindent\ifAfour\begin{minipage}[t]{11.5cm}\else\begin{minipage}[t]{10cm}\fi
\setstretch{0.875}
Спробуємо забрати не~одну, а~дві з трьох паличок, тобто лишити одну; програма-суперниця забирає її і теж виграє.
\end{minipage}}%
\exmp{5
~
1
~
2}{~
1
~
1
~
You won...}{\noindent\ifAfour\begin{minipage}[t]{11.5cm}\else\begin{minipage}[t]{10cm}\fi
\setstretch{0.875}
У купці спочатку п'ять паличок.
Ваша програма забирає одну, лишається чотири;
програма-суперниця забирає одну, Вашій програмі дістається три палички, й вона ніяк не може виграти з вищеописаних причин.
\end{minipage}}%
\exmp{5
~
3}{~
2
~
You won...}{\noindent\ifAfour\begin{minipage}[t]{11.5cm}\else\begin{minipage}[t]{10cm}\fi
\setstretch{0.875}
% У купці з самого початку 5 паличок.
% Ваша програма забирає дві, лишається три;
% Спробуємо забрати 2 з 5 паличок (лишається 3);
% програма-суперниця забирає всі 3 (має право, бо Ваша програма щойно взяла 2) й теж виграє.
Спробуємо забрати дві з п'яти паличок (лишається три); програма-суперниця забирає всі три (має право, бо Ваша програма щойно взяла дві) й теж виграє.
\end{minipage}}%
\end{exampleThreeWithSpecNameColTwoAndLineStretch}

}

\Notes
(1)~Всі наведені послідовності ходів є прикладами правильної гри.
Ваша програма не~зобов'язана при різних запусках для однієї початкової кількості паличок робити різні ходи. 
Але вона має таке право.
Якщо Ваша програма при різних запусках грає по-різному, 
% й це призводить до різних результатів, 
система автоматичної перевірки не~шукатиме ні\nolinebreak[2] найкращий, ні~найгірший з результатів, а~просто оцінюватиме перший.
(2)~Вводити/виводити порожні рядки не~треба; додаткові вертикальні відступи у пр\'{и}кладах зроблені умовно, щоб краще було видно, хто коли ходить.

% (2)~Ніби порожні рядки між різними ходами зроблені, щоб краще було видно, хто коли ходить; виводити їх не~треба.



\ifStatementOnly
\vfill\par
Для цієї задачі (й~лише для неї) встановлене жорстке обмеження кількості спроб здачі: \begin{itshape}\begin{bfseries}не~більше 5 (п'яти) спроб на одного учасника\end{bfseries}\end{itshape}.\par
Всі задачі цього змагання, включно з цією задачею, заборонено повторно здавати в ejudge після того, як вже здано повнобальний розв'язок.
\fi

\end{problem}