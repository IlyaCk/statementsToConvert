\Tutorial	
Наголосимо, що приклад з умови <<\textnumero$\,$3, \textnumero$\,$6, \textnumero$\,$2, \textnumero$\,$7, \textnumero$\,$5, \textnumero$\,$1>> якраз відповідає описаним словами правилам:
\begin{itemize}
\item
Маємо (<<закручену>>) послідовність 1~2~3~4~5~6~7. Рахуємо, починаючи з \textnumero$\,$1, доки не дійдемо до~3, тобто кажемо 
<<1>> на \textnumero$\,$1, 
<<2>> на \textnumero$\,$2, 
<<3>> на \textnumero$\,$3. Значить, прибрати з~кола слід к\'{у}льку \textnumero$\,$3.
\item
Маємо (<<закручену>>) послідовність 1~2~4~5~6~7, і обрахунки починаються з~к\'{у}льки \textnumero$\,$4 (наступної після щойно прибраної к\'{у}льки \textnumero$\,$3).
Тобто, кажемо 
<<1>> на \textnumero$\,$4, 
<<2>> на \textnumero$\,$5, 
<<3>> на \textnumero$\,$6, і прибираємо з~кола к\'{у}льку \textnumero$\,$6.
\item
<<Закручена>> послідовність 1~2~4~5~7, починаємо з~к\'{у}льки\nolinebreak[3] \textnumero$\,$7\nolinebreak[3] --- кажемо 
<<1>> на \textnumero$\,$7, 
<<2>> на \textnumero$\,$1, 
<<3>> на \textnumero$\,$2, і прибираємо к\'{у}льку \textnumero$\,$2.
\item
<<Закручена>> послідовність 1~4~5~7, починаємо з~к\'{у}льки\nolinebreak[3] \textnumero$\,$4\nolinebreak[3] --- кажемо 
<<1>> на \textnumero$\,$4, 
<<2>> на \textnumero$\,$5, 
<<3>> на \textnumero$\,$7, і прибираємо к\'{у}льку \textnumero$\,$7.
\item
<<Закручена>> послідовність 1~4~5, починаємо з~к\'{у}льки\nolinebreak[3] \textnumero$\,$1\nolinebreak[3] --- кажемо 
<<1>> на \textnumero$\,$1, 
<<2>> на \textnumero$\,$4, 
<<3>> на \textnumero$\,$5, і прибираємо к\'{у}льку \textnumero$\,$5.
\item
<<Закручена>> послідовність 1~4, починаємо з~к\'{у}льки\nolinebreak[3] \textnumero$\,$1\nolinebreak[3] --- кажемо 
<<1>> на \textnumero$\,$1, 
<<2>> на \textnumero$\,$4, 
<<3>> на \textnumero$\,$1 і прибираємо к\'{у}льку \textnumero$\,$1.

Лишається єдина к\'{у}лька \textnumero$\,$4, вона й буде відповіддю.
\end{itemize}
На жаль, деякі учасники це не зрозуміли, стверджуючи, ніби к\'{у}льки слід забирати у порядку <<\textnumero$\,$3,~\textnumero$\,$6, \textnumero$\,$2, \textnumero$\,$5, \textnumero$\,$1, \textnumero$\,$4,~\textnumero$\,$7>>. Хоча це протирічить тому, що к\'{у}льки \underline{\emph{забирають}} з кола. І~взагалі, приклади для того й наводять, щоб учасники могли звірити з ними своє розуміння задачі; невідповідність прикладу словесному опису\nolinebreak[3] --- ненормальна ситуація, що трапляється дуже рідко, і\nolinebreak[3] тут її не\nolinebreak[3] було.

Щодо власне розв'язку --- 
при ${N\,{\<}\,100}$ годиться який-небудь спосіб <<у~лоб>>. Наприклад, підтримувати масив із\nolinebreak[2] номерами ще\nolinebreak[3] не\nolinebreak[3] забраних к\'{у}льок, якось так:

\begin{enumerate}
\item
Заповнити масив як \texttt{for i:=1 to N do who[i]:=i};
\item
встановити поточну позицію на початковий індекс~1;
\item
${N\,{-}\,1}$ раз повторити такі дії:
\begin{enumerate}
\item
обчислити, яка позиція знаходиться на\nolinebreak[3] ${K\,{-}\,1}$ правіше поточної (з~урахуванням <<закільцованості>> послідовності), і~перейти туди;
\item
видалити елемент у поточній позиції (зі~зсувом <<хвоста>>).
\end{enumerate}
\end{enumerate}

Повторювати треба ${N\,{-}\,1}$ раз, бо один останній елемент лишається. Змінювати позицію від поточної треба на ${K\,{-}\,1}$, бо сама поточна\nolinebreak[3] --- вже або перша, а\nolinebreak[3] не\nolinebreak[3] нульов\'{а} (на\nolinebreak[2] першій ітерації циклу), або перша \emph{після} щойно видаленої (на\nolinebreak[3] подальших ітераціях), 
% тож 1~з~$K$ вже враховано, лишається\nolinebreak[3] ${K\,{-}\,1}$.
тож лишається зсув\nolinebreak[2] на\nolinebreak[3] ${K\,{-}\,1}$.

Приклади реалізації щойно наведеного алгоритму: \IdeOne{sRGzzS} (Pascal), \IdeOne{0tr18C} (C++\nolinebreak[2] з\nolinebreak[3] активним використанням\nolinebreak[3] STL). Зверніть увагу, що в обох реалізаціях при обчисленні нової поточної позиції береться залишок від ділення на поточну (не~початкову!) кількість к\'{у}льок (наприклад, \verb"p:=(p+(k-1))"\nolinebreak[3] \verb"mod n"), і такий підхід значно кращий, ніж щось у стилі ``\texttt{\mbox{p:=p+(k-1);} if p>N then \mbox{p:=p-N};}'', бо кількість к\'{у}льок зменшується аж~до~однієї (ну,~двох, якщо рахувати перед останнім вилученням), так що $K$ запросто може багатократно перевищувати зменшене~$N$. (Власне, в~умові взагалі нема обмеження на~$K$; раптом з самого початку\nolinebreak[2] ${K\,{>}\,N}$? Це,\nolinebreak[2] в~принципі, недолік умови; але, оскільки все\nolinebreak[3] одно є причини бр\'{а}ти \texttt{mod~N}, несуттєвий.)
Складність цього алгоритму становить\nolinebreak[3] $O(N^2)$ (кожен зсув потребує $O(N)$\nolinebreak[3] дій), що для ${1\,{\<}\,N\,{\<}\,100}$ цілком прийнятно (навіть <<із~запасом>>).

Є й інші % більш-менш 
прості способи, прийнятні при ${%1\,{\<}\,
N\,{\<}\,100}$. Наприклад, при вилученні к\'{у}льки можна не зсовувати хвіст масиву, а\nolinebreak[3] ставити якесь спеціальне число (\mbox{як-то}\nolinebreak[3] \mbox{--1}), яке позначало~б <<видалено>>. Тоді, щоб знайти число, яке видалятимуть наступним, треба послідовно перебирати елементи масива, відраховуючи $K$ (чи\nolinebreak[3] $K\mathbin{\mathrm{mod}}N_{curr}$%, де\nolinebreak[2] $N_{curr}$\nolinebreak[3] --- поточна кількість к\'{у}льок
) ще\nolinebreak[3] не\nolinebreak[3] видалених і пропускаючи вже видалені.

Ця задача має назву (<<Йосипа Флавія>>, рос.\nolinebreak[3] <<Иосифа Флавия>>, англ.\nolinebreak[3] <<Josephus problem>>), і для неї відомі ефективніші алгоритми. Охочі можуть знайти їх, але вони складніші й були~б актуальними лише для значно більших~$N$.
