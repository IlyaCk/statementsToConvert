\Tutorial	
Очевидний підхід\nolinebreak[3] --- бр\'{а}ти кожне число \mbox{1-го} рядка, і шукати його в\nolinebreak[3] усіх інших рядках. Якщо знайдене в\nolinebreak[3] усіх\nolinebreak[3] --- поточне число слід включити у\nolinebreak[3] відповідь (а\nolinebreak[3] якщо\nolinebreak[2] ні, то\nolinebreak[3] ні).
І\nolinebreak[3] цей підхід \emph{може} бути правильним. Але\nolinebreak[2] \emph{залежно} від того, чи\nolinebreak[3] реалізувати його наївно, чи\nolinebreak[3] ефективно. 

Наївно\nolinebreak[3] --- для пошуку кожного числ\'{а} в кожному рядку запускати свій цикл, переглядаючи увесь рядок. Такий розв'язок потреб\'{у}є $O(N{\cdot}M^2)$ часу, що може не\nolinebreak[3] вкладатися в обмеження. Власне, $1234^3\dib{{\approx}}{1{,}88{\cdot}10^9}$ простих порівнянь на\nolinebreak[2] потужному сервері могло~б і поміститися у\nolinebreak[3] 3~сек. Але в\nolinebreak[3] тому й смисл задачі, щоб реалізувати щось ефективніше; на\nolinebreak[3] потужнішому сервері або ставили~б жорсткіший time\nolinebreak[2] limit, або давали вхідні дані ще більших розмірів. На\nolinebreak[3] тому сервері, що був у 2013~році, такий розв'язок благополучно отримував свої 120\nolinebreak[3] балів з~300 (якщо вчасно робити \texttt{break}\nolinebreak[3] --- \emph{трохи} більше).

\MyParagraph{Правильний розв'язок \textnumero$\,$1.}
Той самий підхід можна реалізувати ефективніше завдяки тому, що кожен рядок гарантовано впорядкований. Адже для впорядкованих масивів можливий \emph{бінарний пошук} (скорочено \emph{бін\-пошук}, він\nolinebreak[3] же \emph{двійковий пошук}, він\nolinebreak[3] же \emph{дихотомія}).\phantomsection\label{text:omnipresent-numbers-binsearch} Суть бінпошуку: щоб знайти значення, починають з\nolinebreak[3] середнього (за\nolinebreak[3] індексом) елемента; якщо раптом він якраз рівний шуканому значенню, пошук успішно завершений; якщо шукане значення більше за\nolinebreak[3] середній елемент, то\nolinebreak[3] можна відкинути усю ліву половину масиву, а\nolinebreak[3] якщо менше~--- усю праву половину. На\nolinebreak[3] наступному кроці (якщо він взагалі потрібен) робиться те\nolinebreak[3] с\'{а}ме, але з половиною, що залишилась. І\nolinebreak[3] так далі. Тобто, за\nolinebreak[2] \mbox{1--2}\nolinebreak[2] порівняння можна зменшити діапазон пошуку щонайменше вдвічі, і\nolinebreak[2] пошук у\nolinebreak[2] масиві розміром\nolinebreak[2] 1234 потребує до\nolinebreak[2] ${\approx}20$\nolinebreak[3] порівнянь (асимптотично\nolinebreak[3] --- $O(\log{}M)$). А\nolinebreak[3] $N{\cdot}M$\nolinebreak[2] штук \emph{таких} пошуків поміщаються в обмеження. 

Рекомендується знайти в\nolinebreak[3] Інтернеті або літературі додаткові деталі щодо бін\-пошуку. Бо\nolinebreak[3] це такий алгоритм, у\nolinebreak[3] якому, навіть добре знаючи загальну ідею, легко помил\'{и}тися й отримати код, який часто працює правильно, але іноді зациклюється або видає неправильні результати (див., зокрема, стор.~\pageref{text:binsearch-fails-examples}). 
До\nolinebreak[3] речi, на цьому ж сайтi \texttt{ejudge.ckipo.edu.ua} є змагання\nolinebreak[3] 53\nolinebreak[2] <<Дорiшування теми ``Бiнарний та тернарний пошуки'' Школи Бобра (23.10.2016)>>, де є i теоретичнi матерiали, i комплект задач.

Тим, хто пише мовою\nolinebreak[3] C++, рекомендується вивчити, як у\nolinebreak[3] деяких ситуаціях (включно з цією задачею) можна не\nolinebreak[3] писати бін\-пошук самому, якщо навчитися правильно користуватися функцією \verb"lower_bound" бібліотеки\nolinebreak[2] \texttt{algorithm}.


\MyParagraph{Правильний розв'язок \textnumero$\,$2.}
Ще один правильний розв'язок (із\nolinebreak[2] \emph{кращою} асимптотичною оцінкою $O(N{\cdot}M)$ проти $O(N{\cdot}M{\cdot}\log{}M)$ у\nolinebreak[3] попереднього; але чітко розрізняти цю відмінність за часом роб\'{о}ти програми не~дуже реально, тому попередній розв'язок теж вважається ефективним)\nolinebreak[3] --- багатократно застосовувати модифікацію \emph{злиття} (рос.\nolinebreak[3] \emph{слияние}, англ.\nolinebreak[3] \emph{merge}). %TODO перевірити на актуальному залізі

\phantomsection\label{text:about-merge-in-omnipresent-task}%
Суть стандартного злиття така. Нехай є дві (\emph{обов'язково впорядковані!}) послідовності (зазвичай масиви або фрагменти одного масиву, але можуть бути й інші, як-то файли чи зв'язні списки). З~них можна легко й швидко сформувати впорядковану 
% послі\-дов\-ність-від\-повідь, куди входять усі елемети обох заданих послідовностей, якщо діяти так. 
послідовність, куди входять усі елемети обох заданих послідовностей. 
Призначаємо кожній зі вхідних послідовностей поточну позицію як початок цієї послідовності; повторюємо у\nolinebreak[3] циклі такі дії: (1)~беремо (пишемо у\nolinebreak[3] відповідь) менший з поточних елементів (якщо елементи рівні, то беремо, наприклад, поточний елемент першої послідовності); (2)~зсуваємо поточну позицію тієї вхідної послідовності (\emph{лише однієї з двох!}), звідки взятий цей елемент. Коли одна з послідовностей закінчується, дописуємо у послі\-дов\-ність-від\-по\-відь увесь ще\nolinebreak[3] не\nolinebreak[3] використаний <<хвіст>> іншої. Це\nolinebreak[3] --- \emph{стандартне} злиття, що формує послідовність, яка містить усі елементи обох послідовностей. Очевидно, воно працює за час $O({l_1\,{+}\,l_2})$, де\nolinebreak[3] $l_1$\nolinebreak[1] та\nolinebreak[3] $l_2$\nolinebreak[3] --- довж\'{и}ни вхідних послідовностей.

У\nolinebreak[3] задачі треба інше (спільні елементи). Але злиття легко модифікувати\nolinebreak[2] під~це. Треба при порівнянні поточних елементів двох послідовностей розрізняти три випадки: якщо поточний елемент \mbox{1-ої} послідовності 
% строго 
менший за поточний елемент \mbox{2-ої}, то зсунути поточну позицію \mbox{1-ої} (нічого не~пишучи у~відповідь); якщо 
% строго 
більший, то зсунути позицію \mbox{2-ої} (теж не~пишучи); якщо поточні елементи рівні, то записати це однакове (спільне) значення у результат та зсунути поточні позиції обох послідовностей. При завершенні однієї з послідовностей, \emph{не}~дописувати <<хвіст>> іншої. Час роботи цього модифікату злиття теж $O({l_1\,{+}\,l_2})$.

Зрештою, це\nolinebreak[3] --- злиття \emph{двох} послідовностей, а~треба~$N$. Пропонується першого разу злити \mbox{1-ий} рядок з \mbox{2-им}, а\nolinebreak[3] потім зливати з кожним черговим (\mbox{3-ім},\nolinebreak[2] \mbox{4-им},~\dots) результат попереднього злиття. \emph{Завдяки} тому, що завжди вибираються лише спільні елементи, розмір кожної з послідовностей${}\<M$, тому ${N{-}1}$ застосувань злиття займуть сумарний час $O(N{\cdot}M)$. (\emph{Якби} робилося стандартне злиття і розміри зростали, оцінка була~б значно більшою.)

Знайдіть додаткову інформацію про злиття. Її\nolinebreak[2] багато, але про злиття часто пишуть як про складову сортування, а\nolinebreak[3] тут потрібне \emph{сам\'{е} злиття, без} рекурсивної надбудови сортування. Крім того, не\nolinebreak[3] всі алгоритми, які правильно виконують стандартне злиття, легко модифікуються на вибір лише спільних елементів.
До\nolinebreak[3] речi, на цьому ж сайтi \texttt{ejudge.ckipo.edu.ua} є змагання\nolinebreak[3] 61\nolinebreak[2] <<День Іллі Порубльова ``Школи Бобра'' (15.10.2017, злиття та два вказівники)>>, в якому є i теоретичнi матерiали, i комплект задач.

Користувачам С++ можна також ознайомитися з \emph{готовою} потрібною модифікацією злиття\nolinebreak[3] --- функцією \verb"set_intersection" бібліотеки \verb"algorithm".

Таким чином, грамотні користувачі\nolinebreak[3] C++ в\nolinebreak[3] обох наведених способах розв'язання у~виграші, бо можуть значну частину потрібного алгоритму не~писати самостійно, а\nolinebreak[3] використати бібліотечні засоби. Водночас, малодосвідчені користувачі\nolinebreak[3] C++ у~програші, бо можуть і не~знати, як вирішити проблему, що читання \verb"cin"-ом не~вкладається у\nolinebreak[3] обмеження часу. (Як? Див.~стор.~\pageref{text:io-streams-versus-scanf-printf}\ifnum\getpagerefnumber{text:io-streams-versus-scanf-printf}<\getpagerefnumber{text:io-streams-versus-scanf-printf-end}--\pageref{text:io-streams-versus-scanf-printf-end}\fi.)


\MyParagraph{Навіщо в умові згадані групи тестів зі значеннями до 12345?}
Щоб дати можливість набрати ще~${\approx}20$\%~балів тим, хто не~додумався ні до одного з правильних способів, але\nolinebreak[3] знає наступний, складністю $\Theta(N{\cdot}M\dib{{+}}V)$, де\nolinebreak[3] $V$\nolinebreak[3] --- розмір діапазону від мінімума до максимума можливих значень.

Мається на увазі, що програму в цілому можна організувати як <<\texttt{if} (розміри малі) \texttt{then} (вирішити способом згаданим на самому початку розбору) \texttt{else} (вирішити описаним далі способом)>>. Вхідні дані, коли великі одночасно і\nolinebreak[3] кількості, і\nolinebreak[3] значення, такий розв'язок не\nolinebreak[3] пройде, але, можливо, набере більше балів.

Так от, для малих значень ефективний такий підхід. Заведемо масив, \emph{індексами} якого будуть \emph{значення} зі\nolinebreak[3] вхідних даних, щоб щоразу, прочитавши деяке~\texttt{v}, збільшувати\nolinebreak[2] \texttt{num[v]}\nolinebreak[2] на~1 (спочатку всі\nolinebreak[3] \texttt{num[$\cdot$]} ініціалізуються нулями). Таким чином, після обробки усіх вхідних даних кожне значення\nolinebreak[2] \texttt{num[v]} означатиме, скільки разів зустрілося число~\texttt{v}; оскільки у\nolinebreak[3] кожному окремо взятому рядку всі ч\'{и}сла різні, то \mbox{\texttt{num[v]=N}} рівносильно <<\texttt{v}~зустрілося в усіх рядках>>.\phantomsection\label{text:omnipresent-numbers-end}
