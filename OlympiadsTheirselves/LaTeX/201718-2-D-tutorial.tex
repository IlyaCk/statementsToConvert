\Tutorial
Для \mbox{1-го} (${N\,{=}\,1}$) та \mbox{2-го} (${M\,{=}\,1}$) блоків досить моделювати рух послідовності Пробки крізь єдиний циліндр Дірки чи рух єдиного циліндру Пробки крізь послідовність Дірки відповідно, й на~кожному кроці перевіряти, чи~впирається черговий циліндр Пробки в єдиний циліндр Дірки чи єдиний циліндр Пробки в черговий циліндр Дірки. За посиланням 
\IdeOne{u3mBLC}
наведено код, який по\nolinebreak[2] суті лише\nolinebreak[2] це й перевіряє. Він\nolinebreak[2] набирає 144\nolinebreak[3] бали\nolinebreak[2] з~300, серед яких 120 том\'{у}, що згідно описаного оцінювання і повинен їх набрати за \mbox{1-й} та \mbox{2-й} блоки, а\nolinebreak[3] ще\nolinebreak[3] 24 практично випадково (що\nolinebreak[3] буває при потестовому оцінюванні, яке\nolinebreak[2] у\nolinebreak[2] 2017~р. все\nolinebreak[3] ще було єдиним можливим на\nolinebreak[3] цьому етапі; див.\nolinebreak[3] також\nolinebreak[2] стор.~\mbox{\pageref{text:about-by-test-and-by-block-scoring-start}\ifnum\getpagerefnumber{text:about-by-test-and-by-block-scoring-start}=\getpagerefnumber{text:about-by-test-and-by-block-scoring-finish}\else--\pageref{text:about-by-test-and-by-block-scoring-finish}\fi}). Це\nolinebreak[3] частково свідчить про недостатню продуманість тестів, але й частково завдячує непоганій продуманості коду на р\'{і}вні таких прийомів: хоча код правильний лише при $N{=}1$ або $M{=}1$, будемо застосовувати один з цих підходів також і в~решті випадків; розміри масивів візьмемо максимальними відносно всіх тестів, а~не~лише блоків~\mbox{1--2}.\label{text:dump-and-hole-partial-solution-1-2} Адже якщо все це зробити, то шанси взяти якісь випадкові бали~є, якщо не~робити\nolinebreak[3] --- нема.

Тепер розглянемо, як написати код, який гарантовано розв'язує блоки\nolinebreak[2] \mbox{1--3} плюс випадково деякі тести блоку~4. Спочатку розглянемо, чи\nolinebreak[3] впирається найнижчий циліндр Пробки у найвищий циліндр Дірки (якщо так, то відповідь$\,$=$\,$0 й не~треба більш нічого перевіряти). Інакше, розглянемо дві пари циліндрів, які можуть дати відповідь~1 (найнижчий циліндр Пробки впирається у \mbox{2-й} згори циліндр Дірки, або \mbox{2-й} знизу циліндр Пробки впирається у найвищий циліндр Дірки), і якщо хоча~б одна з двох пар впирається, то відповідь$\,$=$\,$1 (вона не~більша, бо знайдено пару циліндрів, які впираються при заглибленні~1, і\nolinebreak[2] не~менша, бо\nolinebreak[2] це\nolinebreak[2] вже було~б визначено раніше). І\nolinebreak[3] так далі: три можливі пари циліндрів, що можуть дати відповідь~2, потім чотири можливі пари циліндрів, що можуть дати відповідь~3,~\dots{} Додаткового клопоту завдають ситуації, коли низ Пробки вже вийшов за межі Дірки та/або верх Пробки вже занурився нижче верху Дірки, а\nolinebreak[2] інші пари циліндрів все\nolinebreak[3] ще треба порівнювати, бо вони все\nolinebreak[3] ще можуть впертися; при\nolinebreak[3] неакуратному програмуванні тут можуть бути виходи за межі масиву. Можна пробувати вирішити цю проблему, умовно <<доточивши>> Пробку циліндрами дуже малого радіусу, а\nolinebreak[2] Дірку\nolinebreak[3] --- циліндрами дуже великого радіусу, і\nolinebreak[3] це\nolinebreak[3] може бути компромісом між ефективністю та простотою коду. Але все~ж код з <<доточуваннями>> \IdeOne{CEOf36} набирає менше балів, ніж код \IdeOne{r8j9FS}, де не~витрачається час на неіснуючі пари циліндрів. 
Ще\nolinebreak[3] з\nolinebreak[3] іншого боку, такий код не~дуже\nolinebreak[2] простіший, ніж наведені далі способи взяти повні бали.

\MyParagraph{Заміна Дірки та Пробки на монотонні.}
Оскільки Пробку вставляють у Дірку строго згори донизу, зберігаючи вісі спільними, очевидно, що і~Пробку, і~Дірку можна замінити на Пробку та Дірку, в яких послідовності радіусів циліндрів монотонні: у~Пробці, чим вищу частину дивимось, тим вона ширша, а~у~Дірці, чим глибшу частину дивимось, тим вона вужча. Якось так:

\vspace{0pt plus 5mm}

\begin{small}

\input 201718-2-D-statement-picture

\noindent
\begin{tabular}{@{}c|c|c@{}}
\begin{mfpic}[6.5]{-10}{10}{0}{8}
\Bung{5}{4}{2}{4}{9}{7}%{\hatch}
\Axe{-0.25}{6.5}
\end{mfpic}
&
\begin{mfpic}[6.5]{-13}{13}{-8}{1}
\Hole{10}{7}{5}{6}{8}{11}{3}{12}%{\lhatch}
\Axe{-7.25}{0.5}
\end{mfpic}
&
\begin{mfpic}[6.5]{-10}{10}{0}{8}
\Bung{5}{4}{2}{4}{9}{7}%{\hatch}
\begin{coords}
\shift{(0,5)}
\Hole{10}{7}{5}{6}{8}{11}{3}{12}%{\lhatch}
\end{coords}
\Axe{-2.25}{6.5}
\end{mfpic}
\\
\begin{Huge}$\downarrow$\end{Huge}
&
\begin{Huge}$\downarrow$\end{Huge}
&
\begin{Huge}$\downarrow$\end{Huge}
\\
\begin{mfpic}[6.5]{-10}{10}{0}{8}
\Bung{5}{4}{2}{4}{9}{7}%{\hatch}
\Axe{-0.25}{6.5}
\pen{2pt}
\lines{(-9,6),(-9,4),(-5,4),(-5,0),(5,0),(5,4),(9,4),(9,6)}
\end{mfpic}
&
\begin{mfpic}[6.5]{-13}{13}{-8}{1}
\Hole{10}{7}{5}{6}{8}{11}{3}{12}%{\lhatch}
\Axe{-7.25}{0.5}
\pen{2pt}
\lines{(-10,0),(-10,-1),(-7,-1),(-7,-2),(-5,-2),(-5,-6),(-3,-6),(-3,-7)}
\lines{(10,0),(10,-1),(7,-1),(7,-2),(5,-2),(5,-6),(3,-6),(3,-7)}
\end{mfpic}
&
\begin{mfpic}[6.5]{-10}{10}{0}{8}
\Bung{5}{4}{2}{4}{9}{7}%{\hatch}
\begin{coords}
\shift{(0,5)}
\Hole{10}{7}{5}{6}{8}{11}{3}{12}%{\lhatch}
\end{coords}
\Axe{-2.25}{6.5}
\pen{2pt}
\lines{(-9,6),(-9,4),(-5,4),(-5,0),(5,0),(5,4),(9,4),(9,6)}
\begin{coords}
\shift{(0,5)}
\lines{(-10,0),(-10,-1),(-7,-1),(-7,-2),(-5,-2),(-5,-6),(-3,-6),(-3,-7)}
\lines{(10,0),(10,-1),(7,-1),(7,-2),(5,-2),(5,-6),(3,-6),(3,-7)}
\end{coords}
\end{mfpic}
\end{tabular}

\end{small}

\vspace{0pt plus 5mm}

Після цього, є щонайменше два способи використати монотонність отриманих послідовностей, щоб отримати ефективніші, ніж ${O(M\,{\cdot}\,N)}$, алгоритми.

\MyParagraph{Багатократні бінарні пошуки.}
Для кожного з циліндрів Дірки можна шукати бінпошуком, який с\'{а}ме циліндр Пробки упреться у нього, а результати всіх цих пошуків поєднати в аналозі стандартного пошуку мінімуму.
%
Враховуючи, що тут можна не~писати бінпошук вручну (а,\nolinebreak[3] наприклад, використати функцію \verb"lower_bound" з бібліотеки \verb"algorithm"\nolinebreak[2] C++\nolinebreak[3] STL), цей спосіб може виявитися досить простим для реалізації, як\nolinebreak[2] у\nolinebreak[2] \IdeOne{CgmbBs}. Асимптотична складність становить ${\Theta(M\,{\cdot}\,\log{}N)}$, що при $\max(M,N)\dib{{\<}}123456$ 
% розмірах до 123456 
цілком прийнятно.
Можна й <<симетрично>> для кожного циліндру Пробки шукати, в який циліндр Дірки він упреться, й отримати теж прийнятну складність ${\Theta(N\,{\cdot}\,\log{}M)}$.

\MyParagraph{А за $\Theta(N+M)$ можна?}
Так, можна. Щоправда, це мало впливає на фактичний час виконання (спосіб читання вхід\-них даних, див. також стор.~\pageref{text:io-streams-versus-scanf-printf}, впливає сильніше), але теоретично краща оцінка ${\Theta(N\,{+}\,M)}$ тут можлива. На~жаль, ідею дуже важко пояснити словами, тож пропонується читати код \IdeOne{cplW66} (в~якому наведено коментарі), і намагатися співвіднести сам код, коментарі та самостійно виконані приклади застосування цього коду до різних вхідних даних. Цей\nolinebreak[3] алгоритм навіть\nolinebreak[3] не~є якимсь класичним; він має дещо спільне зі злиттям (див.\nolinebreak[3] стор.~\pageref{text:about-merge-in-omnipresent-task}% та трохи далі по тексту
), але небагато.

%%%% Цей алгоритм складності $\Theta(N+M)$ навіть 

\vspace{1pt plus 1in}

