\Tutorial	Ця задача, хоч і нескладна, потребує і~з'ясувати правило, за яким слід вибирати вагони, і~написати не~зовсім елементарну програму. 

Тож правило\nolinebreak[3] --- \textsl{<<Щоразу вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок, доки\nolinebreak[3] не\nolinebreak[3] вичерпається вантажопідйомність корабля або не будуть задіяні всі вагони>>}.

\phantomsection\label{text:proof-example-train-to-ship} %%% міркування щодо доведень перенесені звідси у FAQ
\emph{Доведемо} (див.\nolinebreak[2] також стор.~\pageref{text:need-or-no-need-to-prove}), що це дасть максимальну кількість вагонів.
\textsl{<<Припустимо, ніби замість вагона з мінімальною кількістю коробок взяли вагон з деякою більшою кількістю. Це\nolinebreak[3] збільшило кількість розвантажених вагонів так\nolinebreak[3] с\'{а}мо\nolinebreak[1] на~1, якби взяли вагон з мінімальною, а\nolinebreak[3] залишок вантажо\-підйом\-ності корабля зменшило сильніше. Отже, ніякого виграшу від того, щоб брати вагон з немімінальною кількістю коробок,\nolinebreak[1] \mbox{нема}>>.} 
Ця\nolinebreak[2] схема доведень типова, тобто її аналоги придатні у багатьох ситуаціях.

% Ні\nolinebreak[3] ці\nolinebreak[2] правила, ні\nolinebreak[3] це
% \nolinebreak[2] доведення не\nolinebreak[2] враховують природне 
% бажання відправити кораблем якомога більше коробок; але це питання 
% більше до умови задачі, чим\nolinebreak[1] до\nolinebreak[2] р\'
% озв'язку. Яку задачу задали, таку й вирішено\dots

Сформульовані правила\nolinebreak[3] --- ще\nolinebreak[2] не\nolinebreak[3] зовсім алгоритм.\linebreak[1] Є\nolinebreak[3] мінімум два способи подальшого їх уточнення (\emph{як\nolinebreak[3] с\'{а}ме \textsl{<<вибирати (ще\nolinebreak[3] не\nolinebreak[3] вибраний) вагон з мінімальною кількістю коробок>>}?}).

Можна застосувати сортування (воно~ж упорядкування), після нього це будуть просто елементи  по\nolinebreak[3] порядку. Особливо зручно, якщо писати мовою, де\nolinebreak[2] є готове бібліотечне сортування (наприклад, у\nolinebreak[2] \IdeOne{sElRrj} використано функцію \verb"sort" бібліотеки \verb"algorithm" мови\nolinebreak[3] C++). Та й якщо писати сортування самому, все ж є деяка зручність у тому, щоб окремо написати та ретельно вивірити правильність сортування, окремо решту дій.

Або, можна багатократно проходити по усьому масиву, вибираючи мінімальний елемент, і\nolinebreak[3] після кожного такого проходу враховувати знайдений елемент та заміняти його на якесь велике значення, щоб не~знаходити повторно. 
Таким чином, можна обійтися без зсувів чи обмінів елементів, що може бути простішим для початківців.
Втім, інших переваг цей спосіб не~має. Зокрема, заявка <<він швидший, бо не~сортує всі елементи, а вибирає лише стільки, скільки треба>> не~витримує критики, бо його складність ${\Theta(N\,{\cdot}\,P)}$, тобто, враховуючи\nolinebreak[3] ${P\,{\<}\,N}$, 
\ifAfour
по суті 
\fi
$O(N^2)$. А~складність \emph{ефективних} сортувань $O(N\log{}N)$, що набагато менше.