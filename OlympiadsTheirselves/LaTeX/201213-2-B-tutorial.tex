\Tutorial	Само собою, треба врахувати, що в якомусь рядку (чи~кількох рядках) одиничок може взагалі не~бути; очевидно, с\'{а}ме тоді слід видавати відповідь\nolinebreak[3] ``--1'' (коли одиничок нема, як\nolinebreak[2] не\nolinebreak[3] крути рядок, одиничка не~з'явиться; коли\nolinebreak[2] є, будь-яку з одиничок можна <<докрутити>> до будь-якого стовпчика, питання лише, як\nolinebreak[3] далеко крутити). Отже, властивість \textsl{<<у\nolinebreak[3] кожному рядку є хоча\nolinebreak[3] б одна одиничка>>} варто перевірити зразу: це і розрізнить, чи\nolinebreak[2] виводити\nolinebreak[3] ``--1'', і\nolinebreak[3] дасть можливість написати такий\nolinebreak[3] \texttt{if}, щоб справді шукати мінімальну кількість ходів лише у~ситуаціях, коли вказана властивість виконується. Тому, в\nolinebreak[3] подальших міркуваннях вважаємо, що це вже перевірено й підтверджено.

Якщо знати, в\nolinebreak[2] якому стовпчику слід зібрати одинички, легко бачити, що для кожного рядка слід розглянути лише найближчу зліва та найближчу справа одинички й вибрати з них ближчу, а~решта одиничок, якщо вони й існують, невигідні для шуканого загального мінімума. При\nolinebreak[2] цьому \emph{може} бути, що <<найближча ліворуч>> і <<найближча праворуч>>\nolinebreak[3] --- одна й та с\'{а}ма одиничка; тим\nolinebreak[2] паче, найближча ліворуч/\nolinebreak[3]пра\-во\-руч одиничка може бути <<за~розривом>> (\mbox{як-то}, для стовпичка~2 найближча ліворуч одиничка у стовпчику\nolinebreak[3] ${M\,{-}\,1}$). Як\nolinebreak[3] це врахувати? Є\nolinebreak[3] щонайменше два варіанти: (А)~працювати з діапазоном індексів масиву від\nolinebreak[2] 0 до\nolinebreak[2] ${M\,{-}\,1}$ (навіть у\nolinebreak[2] Паскалі, де прийнято нумерувати з~1), і зсув на \texttt{k} елементів праворуч виражати як \texttt{\mbox{(c+k)}\nolinebreak[2] mod~M}, на \texttt{k} ліворуч\nolinebreak[3] --- як \texttt{\mbox{(c+M-k)}\nolinebreak[2] mod~M}; (Б)~розглянути втричі ширшу матрицю, де (при тій самій кількості рядків) тричі повторено вміст заданої, й шукати найближчі одинички лише для стовпчиків від ${M\,{+}\,1}$ до\nolinebreak[3] ${2\,{\cdot}\,M}$; тоді <<зарозривні ліві>> одинички потрапляють у проміжок від ${1}$ до~${M}$, <<зарозривні праві>>\nolinebreak[3] --- від ${2\,{\cdot}\,M\,{+}\,1}$ до~${3\,{\cdot}\,M}$.

Але ж ми не~знаємо, в\nolinebreak[2] якому стовпчику вигідно збирати одинички! Що\nolinebreak[3] ж, не~знаємо. Але ніщо не~заважає перебрати всі можливі варіанти:
\begin{enumerate} 
\item	зовнішній цикл перебирає, в~якому стовпчику намагаємося зібрати одинички;
\item	вкладений у нього цикл перебирає всі рядки;
\item	вкладені в нього два (послідовні один відносно \'{о}дного) цикли шукають, як\nolinebreak[2] далеко праворуч та як\nolinebreak[2] далеко ліворуч одиничка (у\nolinebreak[3] поточному, визначеному циклом\nolinebreak[3] \textnumero$\,$2, рядку, від поточного, визначеного циклом\nolinebreak[3] \textnumero$\,$1, стовпчика).
\end{enumerate}

Само собою, з результатів двох циклів \textnumero$\,$3a та\nolinebreak[3] \textnumero$\,$3b вибирається мінімум (звідки, справа чи зліва, ближче привести одиничку), цикл\nolinebreak[3] \textnumero$\,$2 рахує суму цих мінімумів (треба отримати одинички в усіх рядках), цикл\nolinebreak[3] \textnumero$\,$1 вибирає мінімум з цих сум. 
%
Легко бачити, що цикл \textnumero$\,$1 має $\Theta(M)$ ітерацій, 
цикл\nolinebreak[3] \textnumero$\,$2\nolinebreak[3] $\Theta(N)$, 
цикли\nolinebreak[3] \textnumero$\,$3\nolinebreak[3] $O(M)$ обидва сумарно, 
що разом дає ${O(N\,{\cdot}\,M^2)}$, що при ${M,\,N\,{\<}\,100}$ цілком прийнятно.
(Що\nolinebreak[3] таке ``$O$'' та\nolinebreak[2] ``$\Theta$'' та як вони доводять це твердження, див., зокрема, стор.~\mbox{\pageref{text:asymptotic-defs-begin}--\pageref{text:asymptotic-defs-end}}.)

Приклади реалізації можна бачити за посиланнями \IdeOne{inBG9A} (C++,\nolinebreak[2] ідея~(А) \mbox{2-го} абзацу) та \IdeOne{gI8i5e} (Pascal, ідея~(Б)).

Якби обмеження були дещо більшими, можна було~б замінити найбільш вкладені цикли 3a та 3b бінарними пошуками (див.\nolinebreak[3] посилання на стор.~\pageref{text:omnipresent-numbers-binsearch}) й тим зменшити оцінку з ${O(N\,{\cdot}\,M^2)}$ до $\Theta(N\,{\cdot}\,M\,{\cdot}\,\log{}M)$. Але тут так робити не~варто.
