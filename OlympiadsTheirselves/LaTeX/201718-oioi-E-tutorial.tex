\Tutorial
Сформуємо два масиви: в одному всі індекси, де зустрічається мінімальне значення, в\nolinebreak[2] іншому\nolinebreak[3] --- 
всі, де максимальне.\ifAfour{} \else\hfill\fi
Наприклад,\ifAfour\\\mbox{}\hfill\else\fi
\begin{tabular}{c|rc@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{$\,$}c@{}}
{початковий масив}
&
{(індекси)}
& \tiny{~(0)}
& \tiny{~(1)}
& \tiny{~(2)}
& \tiny{~(3)}
& \tiny{~(4)}
& \tiny{~(5)}
& \tiny{~(6)}
& \tiny{~(7)}
& \tiny{~(8})
& \tiny{~(9)}
& \tiny{(10)}
& \tiny{(11)}
& \tiny{(12)}
& \tiny{(13)}
& \tiny{(14)}
& \tiny{(15)}
& \tiny{(16)}
& \tiny{(17)}
& \tiny{(18)}
\\
{(вхідні дані)}
&
{(значення)}
&
3 &
1 &
4 &
1 &
5 &
9 &
2 &
6 &
1 &
8 &
2 &
8 &
1 &
8 &
2 &
8 &
4 &
5 &
9
\end{tabular}\ifAfour\hfill\mbox{}\\\else\fi
призводить до формування таких масивів:
\begin{footnotesize}
\begin{tabular}{c|l}
мінімуми
&
1~~~3~~~8~~12
\\\hline
максимуми
&
5~~18
\end{tabular}
\end{footnotesize}.\hspace{0.5em plus 1em}
Потім пройдемо по цим масивам, використовуючи злиття, але не~формуючи послідовність-результат, а шукаючи мінімум серед усіх значень \texttt{abs(a[i]-b[j])}; потім ще~1 відняти наприкінці, якщо тільки це не буде ситуація, коли відповідь і~так~0; на\nolinebreak[3] відміну від попередньої задачі, це\nolinebreak[3] можливо (коли всі елементи рівні). 

На\nolinebreak[3] основі цього можна отримати код \IdeOne{PBDdKu}\nolinebreak[3] (C++).

На стор.~\pageref{text:about-merge-in-omnipresent-task} % та трохи далі по тексту 
є короткий опис злиття та рекомендації щодо інших джерел.

%%% Про сам\'{е} злиття коротко згадано на стор.~\pageref{text:about-merge-in-omnipresent-task}, а трохи далі по тексту є рекомендації щодо інших джерел.

