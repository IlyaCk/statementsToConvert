\Tutorial
\MyParagraph{Що може бути перенесено в цю задачу з попередньої і що ні?}
<<Лобовий>> спосіб може бути перенесений з очевидними змінами, наприклад,
\begin{Huge}
\begin{color}{red}
TODO: add IDEONE links here
\end{color}
\end{Huge}.
І~він так\nolinebreak[3] с\'{а}мо, з\nolinebreak[3] тих\nolinebreak[3] с\'{а}мих причин, повинен проходити лише блоки\nolinebreak[3] \mbox{1--2} (які, втім, тепер дають вже не~30$\,$\%,\nolinebreak[2] а\nolinebreak[3] 40$\,$\% балів). Прочитати короткі пункти на\nolinebreak[3] початку та наприкінці розбору попередньої задачі, якщо цього ще~не~зробили, теж варто.

Але\nolinebreak[2] описані в\nolinebreak[3] попередньому розборі префіксні суми та їх  двовимірне узагальнення \emph{принципово неможливо} пристосувати до цієї задачі. Головним чином том\'{у}, що при їх використанні потрібне віднімання, яке є оберненою операцією до додавання: надодавали зайвого\nolinebreak[3] --- можна відняти це зайве й лишиться те, що треба. А~для мінімума оберненої операції з такими властивостями не~існує: ну~знаємо, що на префіксі <<5~9~2~6~3>> максимумом\nolinebreak[3] є~9,\linebreak[2] на\nolinebreak[2] коротшому префіксі <<5~9>> максимумом теж\nolinebreak[3] є~9\nolinebreak[3] --- це\nolinebreak[2] щось дає для визначення максимума на відрізку <<2~6~3>>, який входить у перший префікс і не~входить у~др\'{у}гий? Нічогісінько.

\MyParagraph{Основна ідея\nolinebreak[3] --- запам'ятовувати результати деяких таких прямокутників, щоб вони потім були частинами потрібного.} С\'{а}ме частинами. Щоб не~виникало потреби <<відкинути зайве>> (а~отже, й потреби у оберненій операції). Є~чимало різних варіантів уточнення цієї основної ідеї. 

\MyParagraph{Варіант $\No\,$1.} Можна, наприклад, запам'ятати максимум 
для прямокутника ``1~10~1~10'' (у~термінах вхідних даних задачі), 
максимум для прямокутника ``1~10~11~20'', 
для\nolinebreak[2] ``1~10~21~30'',\linebreak[2] 
і\nolinebreak[2] так доки\nolinebreak[3] не\nolinebreak[2] закінчаться стовпчики; аналогічно, 
для\nolinebreak[2] ``11~20~1~10'',
для\nolinebreak[2] ``11~20~11~20'',
для\nolinebreak[2] ``11~20~21~30'',\nolinebreak[3]
\dots;\linebreak[2]
для\nolinebreak[2] ``21~30~1~10'',
для\nolinebreak[2] ``21~30~11~20'',
для\nolinebreak[2] ``21~30~21~30'',\nolinebreak[3]
\dots;\linebreak[2]
і\nolinebreak[2] так доки\nolinebreak[3] не\nolinebreak[2] закінчаться рядки.

Звісно, м\'{е}жі прямокутників-запитів не~зобов'язані збігатися з межами цих штучно (непри\-род\-ньо) виділених квадратів, і це слід якось врахувати. Наприклад, так: де квадрат входить у прямокутник-запит повністю, там замість порівнянь поточного максимума з усіма ${10\,{\*}\,10}\dibbb{{=}}100$\nolinebreak[2] числами цього квадрата робити одне-єдине порівняння, а\nolinebreak[3] де\nolinebreak[3] прямокутник-запит зачіпає квадрат лише частково\nolinebreak[3] --- там, як і раніше, перебирати поелементно. 

\myflfigaw{\raisebox{-81pt}[0pt][72pt]{\begin{mfpic}[1.25]{0}{80}{0}{120}
\mirror{(0,40)}{(120,40)}
\hatchcolor{black}
\lhatch\rect{(22,16),(120,72)}
\gclear\rect{(30,20),(120,70)}
\rhatch\rect{(30,20),(120,70)}
\lines{(0,0),(0,80)}
\lines{(10,0),(10,80)}
\lines{(20,0),(20,80)}
\lines{(30,0),(30,80)}
\lines{(40,0),(40,80)}
\lines{(50,0),(50,80)}
\lines{(60,0),(60,80)}
\lines{(70,0),(70,80)}
\lines{(80,0),(80,80)}
\lines{(90,0),(90,80)}
\lines{(100,0),(100,80)}
\lines{(110,0),(110,80)}
\lines{(120,0),(120,80)}
\lines{(0,0),(120,0)}
\lines{(0,10),(120,10)}
\lines{(0,20),(120,20)}
\lines{(0,30),(120,30)}
\lines{(0,40),(120,40)}
\lines{(0,50),(120,50)}
\lines{(0,60),(120,60)}
\lines{(0,70),(120,70)}
\lines{(0,80),(120,80)}
\end{mfpic}}}
Наприклад, на рисунку зображено ситуацію для запиту ``17~72~23~120'' в\nolinebreak[3] масиві\nolinebreak[2] $90\,{\*}\,120$: <<сіткою>> зображено квадрати, однією штриховкою виділено область, де вдалося використати відповіді цілих квадратів, іншою\nolinebreak[3] --- область, де довелося порівнювати поелементно. 
%
Бачимо, що з ${(120\,{-}\,23\,{+}\,1)}\dib{{\times}}{(72\,{-}\,17\,{+}\,1)}\dibbb{{=}}{98\,{\times}\,56}\dibbb{{=}}5488$ елементів вдалося виділити ${9\,{\times}\,5}\dibbb{{=}}45$ квадратів, тож поелементно лишилося перебрати тільки ${5488\,{-}\,4500}\dibbb{{=}}988$.

Це\nolinebreak[3] явно менше\dots{} але \emph{наскільки} (якщо говорити не\nolinebreak[3] про\nolinebreak[3] приклад, а\nolinebreak[3] в\nolinebreak[3] ціл\'{о}му)? Чи~досить цього, щоб пройти усі блоки тестів? І~чи~точно за розмір квадрата варто бр\'{а}ти с\'{а}ме~10, а\nolinebreak[3] не~7\nolinebreak[3] чи~40?

Спробуємо почати з останнього питання. Визначити оптимальний розмір точно неможливо, але, припускаючи, що $N\,{\approx}\,M$ (масив не~надто витягнутий у~ширину чи висоту), цей розмір повинен бути трохи меншим за $\sqrt{N}$ (чи~$\sqrt{M}$, що, за~припущенням, приблизно те~с\'{а}ме), бо при ще менших розмірах квадрата надто мало виграшу від того, що замінюємо одним порівнянням поелементний перебір квадрата, а при ще більших\nolinebreak[3] --- забагато елементів лишається по краям прямокутника-запиту. (Охочі можуть отримати цей висновок як результат математично строгого аналізу засобами шкільного курсу алгебри; але тоді треба ввести якісь додаткові припущення, як-то <<${M\,{=}\,N}$>>, <<розмір прямокутника-запиту становить такий-то відсоток від розміру всього масиву>>, <<при\nolinebreak[2] розмірі квадратів\nolinebreak[2] ${a\,{\times}\,a}$, ширина ``рамки'' з елементів, які доводиться обробляти поелементно, становить $a/2$>>, а\nolinebreak[2] ці\nolinebreak[2] припущення можуть бути надто приблизними, тож точність результату все\nolinebreak[3] одно лишається сумнівною.)

В~межах тих самих (розкритикованих за приблизність) припущень, можна сказати, що кожен з $T$ запитів потреб\'{у}є $O(N\sqrt{N})$ (чи\nolinebreak[3] $O(N\sqrt{M})$, чи\nolinebreak[3] $O(M\sqrt{N})$\nolinebreak[3] ---\linebreak[2] все\nolinebreak[2] це те\nolinebreak[3] с\'{а}мо, бо вже припустили, що $N\,{\approx}\,M$), тобто лише у $\sqrt{N}$ разів менше, ніж <<лобовий>> варіант. Тим\nolinebreak[3] не\nolinebreak[3] менш, при акуратній та оптимальній у деталях реалізації це цілком може пройти блоки\nolinebreak[3] \mbox{1--3} й отримати 80$\,$\%~балів.


\MyParagraph{Варіант $\No\,$2.}
Хоч би й на тому самому прикладі з попереднього рисунка, можна помітити, що <<рамка>>, яку там пропонувалося переглядати поелементно, має досить тонкі й досить довгі верхню, нижню, ліву, праву ст\'{о}рони (конкретно на тому рисунку правої сторон\'{и} нема, але то виключення, а~не~правило). Їх\nolinebreak[2] можна розглянути швидше, ніж поелементно, якщо ввести не~один, а~три допоміжні масиви: 
\texttt{maxInSquare} розмірами ${N/a\,{\*}\,M/a}$, де кожен елемент містить максимум відповідного квадрату\nolinebreak[2] ${a\,{\*}\,a}$ (як\nolinebreak[3] вже з'ясовано, $a$\nolinebreak[3] повинно бути трохи меншим~$\sqrt{N}$; зручно, щоб у\nolinebreak[3] подальших масивах $a$ було те\nolinebreak[3] с\'{а}ме);
\texttt{maxInHorStripe} розмірами ${N/a\,{\*}\,M}$, де кожен елемент містить максимум відповідної горизонтальної смужечки\nolinebreak[2] ${1\,{\*}\,a}$; 
\texttt{maxInVertStripe} розмірами ${N\,{\*}\,M/a}$, де кожен елемент містить максимум відповідної вертикальної смужечки\nolinebreak[2] ${a\,{\*}\,1}$. 

\myflfigaw{\raisebox{-96pt}[0pt][96pt]{\begin{mfpic}[2]{22}{120}{16}{72}
\lines{(30,20),(120,20)}
\lines{(30,30),(120,30)}
\lines{(30,40),(120,40)}
\lines{(30,50),(120,50)}
\lines{(30,60),(120,60)}
\lines{(30,70),(120,70)}
%
\lines{(30,16),(30,72)}
\lines{(40,16),(40,72)}
\lines{(50,16),(50,72)}
\lines{(60,16),(60,72)}
\lines{(70,16),(70,72)}
\lines{(80,16),(80,72)}
\lines{(90,16),(90,72)}
\lines{(100,16),(100,72)}
\lines{(110,16),(110,72)}
\lines{(120,16),(120,72)}
%
\lines{(22,16),(22,72)}
\lines{(23,16),(23,72)}
\lines{(24,16),(24,72)}
\lines{(25,16),(25,72)}
\lines{(26,16),(26,72)}
\lines{(27,16),(27,72)}
\lines{(28,16),(28,72)}
\lines{(29,16),(29,72)}
%
\lines{(22,20),(30,20)}
\lines{(22,30),(30,30)}
\lines{(22,40),(30,40)}
\lines{(22,50),(30,50)}
\lines{(22,60),(30,60)}
\lines{(22,70),(30,70)}
%
\lines{(22,16),(120,16)}
\lines{(22,17),(120,17)}
\lines{(22,18),(120,18)}
\lines{(22,19),(120,19)}
%
\lines{(22,71),(120,71)}
\lines{(22,72),(120,72)}
\end{mfpic}}}
Наприклад, для відповіді на такий самий, як на минулому рисунку, прямокутник-запит ``17~72~23~120'' за того самого розміру квадратиків та смужечок ${a\,{=}\,10}$ були\nolinebreak[3] б використані квадрати, вертикальні й горизонтальні смужки та окремі елементи, зображені на рисунку.

Неважко переконатися, що (при згаданих обмеженнях\nolinebreak[2] ${a\,{\approx}\,\sqrt{N}}$, \nolinebreak[2] ${N\,{\approx}\,M}$) тепер формування відповіді на кожен запит займає $O(N)$: 
квадратів\nolinebreak[2] ${a\,{\*}\,a}$ сумарно не~більш як ${(N/a)\,{\*}\,(M/a)}\dib{{\approx}}{(N/\sqrt{N})\,{\*}\,(N/\sqrt{N})}\dib{{\approx}}{N}$;\linebreak[2]
горизонтальних смужок\nolinebreak[2] ${1\,{\*}\,a}$ сумарно не~більш як двічі (згори і знизу) по ${a\,{\*}\,(M/a)}\dib{{\approx}}{N}$;\linebreak[2]
вертикальних смужок\nolinebreak[2] ${1\,{\*}\,a}$ сумарно не~більш як двічі (ліворуч і праворуч) по ${(N/a)\,{\*}\,a}\dib{{\approx}}{N}$;\linebreak[2]
одинарних елементів не~більш як чотири рази (лівий-верхній, правий-верхній, лівий-нижній та правий-нижній кути) по ${a\,{\*}\,a}\dib{{\approx}}{N}$.
Сумарно, $O(N)$, тобто ще у $\sqrt{N}$ разів менше порівняно з <<варіантом~$\No\,$1>>. Враховуючи, що підготувати всі ці масиви \texttt{maxInSquare}, \texttt{maxInHorStripe} та \texttt{maxInVertStripe} на етапі передобробки все\nolinebreak[3] ще можна за час $\Theta(N{\cdot}M)$, і що в цій задачі максимальні значення $N$,~$M$ дещо менші, ніж у~попередній, а ліміт часу виконання більший, цього вже достатньо для проходження тестів усіх блоків і отримання повного балу.
(Можна було~б зробити й так, щоб цей підхід набирав повні бали також і в попередній задачі\nolinebreak[3] --- тут же не~використовуються ніякі особливості максимуму, які не~виконуються для додавання\dots{} Але підхід із двовимірним узагальненням префіксних сум все-таки і значно ефективніший, і~на суб'єктивну думку автора задач, красивіший, і досить легко пишеться; тому хотілося, щоб він усе-таки проявляв свої переваги.)

\MyParagraph{Варіант $\No\,$3.} 
Цей варіант не~кращий за попередні, але, в~деяких смислах, простіший.
Для кожного рядка окремо, спробуємо запам'ятати готові відповіді від кожного можливого~$j_1$ до кожного можливого~$j_2$. Якби це вдалося, можна було~б для потрібного діапазону $j_1$~$j_2$ щоразу просто бр\'{а}ти готову відповідь (у~межах поточного рядка, а\nolinebreak[3] рядки просто перебирати кожен окремо від\nolinebreak[3] $i_1$\nolinebreak[2] до~$i_2$). 
Щоправда, рівно в такому вигляді потрібен тривимірний масив розмірами ${N\,{\*}\,M\,{\*}\,M}$, і просто не~вистачає пам'яті. Причому, не~лише для останнього блоку тестів, а й для передостаннього: ${400\,{\*}\,400\,{\*}\,400\,{\*}\,4}\dib{{=}}256000000\dibbb{{>}}251658240\dibbb{{=}}{240\,{\*}\,1024\,{\*}\,1024}$ (а~пам'ять потрібна не~лише на цей найбільший масив). Але, якщо провести деякі оптимізації, цей спосіб все-таки можна <<впихнути>> в обмеження. Одна з таких можливих оптимізацій\nolinebreak[3] --- пам'ятати максимуми від \emph{майже} кожного~$j_1$ до \emph{майже} кожного~$j_2$. Наприклад, через один: елемент \texttt{MX[0][0][0]} зберігає максимум серед пари елементів \texttt{data[1][1]}, \texttt{data[1][2]}; елемент \texttt{MX[0][0][1]}\nolinebreak[3] --- максимум серед чотирьох елементів \texttt{data[1][1]}, \texttt{data[1][2]}, \texttt{data[1][3]}, \texttt{data[1][4]}; елемент \texttt{MX[0][0][2]}\nolinebreak[3] --- максимум серед шести елементів від \texttt{data[1][1]} по \texttt{data[1][6]} включно, і~так далі; потім, елемент \texttt{MX[0][1][0]} зберігає максимум серед пари елементів \texttt{data[1][3]}, \texttt{data[1][4]}; елемент \texttt{MX[0][1][1]}\nolinebreak[3] --- максимум серед чотирьох елементів \texttt{data[1][3]}, \texttt{data[1][4]}, \texttt{data[1][5]}, \texttt{data[1][6]}, і~так далі. При цьому об'єм пам'яті зменшується вчетверо, а~відповідь (у~межах рядка), хоч і не~завжди готова для потрібних $j_1$,~$j_2$, але завжди можна отримувати за $\Theta(1)$ (у~межах рядка): вибрати той найкращий проміжок, де ліва межа або~$j_1$, або~${j_1\,{+}\,1}$, пр\'{а}ва\nolinebreak[3] --- або~$j_2$, або~${j_2\,{-}\,1}$, тож лишається тільки взяти готовий результат проміжку, і, якщо треба, врахувати щонайбільше по одному елементу ліворуч та праворуч  (<<\mbox{якщо}\nolinebreak[2] треба>> включає у~себе перевірки, чи~вийшло так, що готовий проміжок недонакрив один елемент, і якщо вийшло, то чи~більший той один елемент за досі знайдений максимум). Але, повторимося, все~це слід робити для кожного рядка від\nolinebreak[3] $i_1$\nolinebreak[2] до~$i_2$ окремо, тож кожен запит займає $O(N)$. І~при цьому потрібен величезний масив, дуже витратний і~за~пам'яттю, і~за~часом його заповнення (само собою, потрібно визначати \texttt{MX[i][j1div2][j2div2]}, ). 
% 
Тим не менш, якщо реалізувати все це якнайефективніше у деталях, таким способом хоч і важко, але в~принципі можна пройти навіть геть усі тести; пройти ж блоки\nolinebreak[3] \mbox{1--3} відносно неважко й менш <<вилизаними>> реалізаціями та менш ефективними мовами програмування.

\MyParagraph{А є щось, що має складність окремого запиту $o(N)$ (тобто, асимптотично строго меншу~$N$)?}
Є,~але ще\nolinebreak[3] складніше. Наприклад, можна почитати у\nolinebreak[3] літературі чи в\nolinebreak[3] Інтернеті про \emph{дерево\nolinebreak[2] відрізків} та його двовимірне узагальнення. Двовимірне дерево відрізків має складність ${\Theta(N{\cdot}M)}$ на етапі передобробки і по $O(\log{N}{\cdot}\log{M})$ на кожен з $T$ запитів, і\nolinebreak[3] при цьому з\nolinebreak[3] мінімальними змінами годиться і~для~сум, і~для~максимумів. Тож цей підхід, хоч і складн\'{и}й, в~принципі дозволяє <<вбити обидві задачі~C,~D одним пострілом>>. Щоправда, для проходження задачі~C (з~більшими $N$,~$M$ при меншому обмеженні часу) треба ще й реалізувати його ефективно у~деталях (асимпотика $O(\log{N}{\cdot}\log{M})$, хоч не~набагато, але більша, ніж $\Theta(1)$ в~узагальнених префіксних сумах).

Розглянемо ще\nolinebreak[3] один підхід, придатний для задачі~D, але~не~C. Він потреб\'{у}є чимало пам'яті: аж ${\Theta(N{\cdot}M{\cdot}\log{N}{\cdot}\log{M})}$;
це\nolinebreak[3] може\nolinebreak[2] бути двовимірний масив розмірами ${\lceil\log_2{N}\rceil\,{\times}\,\lceil\log_2{M}\rceil}$, елементами якого є двовимірні масиви розмірами до\nolinebreak[3] ${N\,{\times}\,M}$ кожен; або, що\nolinebreak[2] майже\nolinebreak[2] те\nolinebreak[3] с\'{а}мо, один 
% чотиривимірний 
\mbox{4-вимір}\-ний 
масив розмірами ${\lceil\log_2{N}\rceil\,{\times}\,\lceil\log_2{M}\rceil\,{\times}\,N\,{\times}\,M}$).
Але зате цей алгоритм найшвидший з відомих автору задачі при великій кількості запитів (кожен з $T$ запитів робиться за $\Theta(1)$, уся передобробка за ${\Theta(N{\cdot}M{\cdot}\log{N}{\cdot}\log{M})}$), і, якщо його зрозуміти, не~такий уже й складн\'{и}й для написання. А~об'єм пам'яті, хоч і величезний, все~ж менший, ніж у <<варіанті~$\No\,$3>>.

Розмістимо чи\nolinebreak[3] то\nolinebreak[2] у\nolinebreak[3] двовимірному масиві двовимірних масивів, чи\nolinebreak[3] то\nolinebreak[2] у\nolinebreak[3] чотиривимірному масиві таку інформацію: \textsl{<<елемент \texttt{[$a$][$b$][$i$][$j$]} дорівнює максимуму серед елементів прямокутника розмірами ${2^a\,{\*}\,2^b}$, який займає 
рядки\nolinebreak[2] від\nolinebreak[3] $i$\nolinebreak[2] до\nolinebreak[3] ${i\,{+}\,2^a\,{-}\,1}$,
стовпчики\nolinebreak[2] від\nolinebreak[3] $j$\nolinebreak[2] до\nolinebreak[3] ${j\,{+}\,2^b\,{-}\,1}$>>}. Тобто, елементи з\nolinebreak[3] індексами \texttt{[0][0][$i$][$j$]} дорівнюють відповідним елементам масиву вхідних даних; елементи з індексами \texttt{[0][1][$i$][$j$]} є максимумами з двох елементів (тих, що у масиві вхідних даних мають індекси \texttt{[$i$][$j$]} та \texttt{[$i$][$j$+1]}); елементи з індексами \texttt{[0][2][$i$][$j$]}\nolinebreak[3] --- максимумами з\nolinebreak[2] \mbox{4-х}\nolinebreak[2] елементів \texttt{[$i$][$j$]},\hspace{0pt plus 0.25em} \texttt{[$i$][$j$+1]},\hspace{0pt plus 0.25em} \texttt{[$i$][$j$+2]} та \texttt{[$i$][$j$+3]}; і\nolinebreak[3] так\nolinebreak[3] далі. Наприклад, елементи з індексами \texttt{[5][3][$i$][$j$]} дорівнюють максимумам з відповідних прямокутників розмірами ${2^5\,{\*}\,2^3}\dibbb{{=}}{32\,{\*}\,8}$ масиву зі вхідних даних, з~проміжком 
рядків\nolinebreak[2] від\nolinebreak[3] $i$\nolinebreak[2] до\nolinebreak[3] ${i\,{+}\,31}$,
стовпчики\nolinebreak[2] від\nolinebreak[3] $j$\nolinebreak[2] до\nolinebreak[3] ${j\,{+}\,7}$
(і~там,\nolinebreak[2] і\nolinebreak[3] там\nolinebreak[3] --- включно).
Подальші деталі (чи~нумерувати $i$,~$j$ з~0, чи\nolinebreak[3] з~1; чи\nolinebreak[3] враховувати, що при підході <<двовимірний масив двовимірних масивів>> для більших\nolinebreak[2] $a$,~$b$ можна робити відповідний вкладений масив уже\nolinebreak[3] не\nolinebreak[3] розмірами ${N\,{\*}\,M}$, а~меншим, як-то ${N{-}2^a{+}1\,{\*}\,M{-}2^b{+}1}$; тощо) можна реалізовувати по-різному (тим\nolinebreak[3] паче, враховуючи особливості різних мов програмування), залишимо це на розсуд читачів. 
Головне, щоб зберігалися максимуми с\'{а}ме таких прямокутників.

Для дотримання вищезгаданої оцінки <<передобробка за ${\Theta(N{\cdot}M{\cdot}\log{N}{\cdot}\log{M})}$>> треба ще забезпечити, щоб такі максимуми формувалися швидко, за $\Theta(1)$ кожен. 
(Насправді, не~обо\-в'\-яз\-ко\-во \emph{кожен}, досить, щоб \emph{в~середньому}; але можна, щоб кожен.) Якось\nolinebreak[2] так: елементи \texttt{M[0][0][$i$][$j$]} просто копіюються з масиву вхідних даних (чи~навіть читаються з файлу вхідних даних прямо туди); усім\nolinebreak[2] \texttt{M[0][1][$i$][$j$]} надається значення $\max\bigl({\texttt{M[0][0][}i\texttt{][}j\texttt{]}},\dib{{}}{\texttt{M[0][0][}i\texttt{][}j{+}1\texttt{]}}\bigr)$, бо с\'{а}ме ці два елементи й утворюють прямокутник\nolinebreak[2] ${1\,{\*}\,2}$; усім\nolinebreak[2] \texttt{M[0][2][$i$][$j$]} надається значення $\max\bigl({\texttt{M[0][1][}i\texttt{][}j\texttt{]}},\dib{{}}{\texttt{M[0][1][}i\texttt{][}j{+}2\texttt{]}}\bigr)$, бо прямокутник\nolinebreak[2] ${1\,{\*}\,4}$ можна подати як два прямокутники\nolinebreak[2] ${1\,{\*}\,2}$, один з яких <<починається>> (має лівий-верхній кут) у тій с\'{а}мій клітинці\nolinebreak[3] $i$,~$j$,\linebreak[2] а~інший на\nolinebreak[3] 2\nolinebreak[3] клітинки правіше (с\'{а}ме\nolinebreak[3] там <<починається>> частина більшого, не~покрита першим меншим); і~так\nolinebreak[3] \mbox{далі}. Для\nolinebreak[2] заповнення \texttt{M[$a$][$b$][$i$][$j$]} при\nolinebreak[3] ${a\,{>}\,0}$, можна, наприклад, надавати всім\nolinebreak[2] \texttt{M[$a$][1][$i$][$j$]} значення $\max\bigl({\texttt{M[}a{-}1\texttt{][0][}i\texttt{][}j\texttt{]}},\dib{{}}{\texttt{M[}a{-}1\texttt{][0][}i{+}1\texttt{][}j\texttt{]}}\bigr)$, а\nolinebreak[3] далі заповнити всі\nolinebreak[2] \texttt{M[$a$][$b$][$i$][$j$]} при\nolinebreak[3] ${b\,{>}\,0}$ аналогічно тому, як вище детально пояснено для\nolinebreak[3] ${a\,{=}\,0}$.

% \myflfigaw{\raisebox{-54pt}[0pt][48pt]{\begin{mfpic}[12]{0}{14}{0}{5}
\myflfigaw{\raisebox{-42pt}[0pt][36pt]{\begin{mfpic}[12]{0}{14}{0}{5}
\hatchcolor{black}
\thatch[2.5pt,15]\rect{(0,0),(8,4)}
\thatch[2.5pt,60]\rect{(0,1),(8,5)}
\thatch[2.5pt,105]\rect{(6,1),(14,5)}
\thatch[2.5pt,150]\rect{(6,0),(14,4)}
\rect{(0,0),(8,4)}
\rect{(6,0),(14,4)}
\rect{(0,1),(8,5)}
\rect{(6,1),(14,5)}
\end{mfpic}}}
Коли увесь вміст описаного масиву~\texttt{M} готовий, можна і зручно скористатися тим, що для будь-якого прямокутника-запиту можна підібрати такі\nolinebreak[3] $a$,~$b$, щоб покрити цей прямокутник-запит рівно\nolinebreak[2] \mbox{4-ма}\nolinebreak[2] прямокутниками однакових розмірів\nolinebreak[2] ${2^a\,{\*}\,2^b}$. (<<Покрити>> тут означає, що: кожен елемент прямокутника-запиту належить хоча\nolinebreak[3] б\nolinebreak[2] одному з\nolinebreak[2] \mbox{4-х}\nolinebreak[2] прямокутників\nolinebreak[2] ${2^a\,{\*}\,2^b}$; жоден з\nolinebreak[2] \mbox{4-х}\nolinebreak[2] прямокутників\nolinebreak[2] ${2^a\,{\*}\,2^b}$ нід\'{е}\nolinebreak[2] ні\nolinebreak[3] на\nolinebreak[3] один елемент не~виходить за м\'{е}жі прямокутника-запиту. Наприклад, на рисунку зображено, як 4~прямокутники\nolinebreak[2] ${4\,{\*}\,8}$ покривають прямокутник-запит\nolinebreak[2] ${5\,{\*}\,14}$.) Як~правило, ці 4~прямокутники\nolinebreak[2] ${2^a\,{\*}\,2^b}$ накладаються частково, але якщо прямокутник-запит має розмір (один чи обидва), що є степен(ем/ями) двійки, отримуємо чи\nolinebreak[3] то\nolinebreak[2] дотикання без накладань, чи\nolinebreak[3] то\nolinebreak[2] повну однаковість прямокутників (двох\nolinebreak[2] пар чи всіх~\mbox{4-х}); з~цим 
розберіться самостійно, 
не~забуваючи, що прямокутник-запит може мати 
% в~тому числі 
в~т.~ч.
й лише один рядок чи стовпчик.

Раніше було пояснено, що алгоритм, ефективний для задачі~C, тут принципово незасто\-сов\-ний, бо\nolinebreak[3] додавання має обернену операцію віднімання, а\nolinebreak[3] максимум не~має оберненої операції. Але максимум має іншу приємну властивість, якої не~має сума: ідемпотентність. 
Це\nolinebreak[3] означає, що байдуже, чи\nolinebreak[3] враховувати кожен потрібний елемент рівно один раз, чи\nolinebreak[3] врахувати деякі один раз, деякі двічі, деякі тричі, тощо. 
С\'{а}ме ідемпотентність максимуму й дає можливість отримувати максимум прямокутника-запиту як максимум з\nolinebreak[3] \mbox{4-х}\nolinebreak[3] результатів для тих прямокутників, якими його покрили, і\nolinebreak[3] байдуже, якщо ці 4~прямокутники накладаються й том\'{у} деякі елементи враховані двічі й деякі по чотири рази. 

Лишилося тільки навчитися швидко перетворювати опис прямокутника-запиту $i_1$,~$i_2$,~$j_1$,~$j_2$ зі\nolinebreak[3] вхідних даних у те, які с\'{а}ме 4~прямокутники\nolinebreak[3] ${2^a\,{\*}\,2^b}$ його покривають. Оскільки деякі технічні моменти вже віддано на розсуд читачів, тут мусимо теж віддати значну частину на розсуд читачів, лише відзначимо деякі факти. 
Для визначення тих $a$,~$b$, при яких якраз вдається покрити прямокутник-запит, можна використати функцію логарифму з математичної бібліотеки, причому логарифм треба бр\'{а}ти від 
вертикального розміру ${i_2\,{-}\,i_1\,{+}\,1}$ та
горизонтального розміру ${j_2\,{-}\,j_1\,{+}\,1}$; щоправда, може бути трохи мороки з тим, щоб узяти с\'{а}ме двійковий логарифм (а~не~натуральний чи десятковий), та з тим, як правильно заокруглити дійсний результат до цілого. Можливий і альтернативний підхід: не~вживаючи логарифми, починаючи з розміру~1 та індексу~0, пробувати щоразу збільшувати розмір удвічі, а\nolinebreak[2] індекс\nolinebreak[3] на~1,\linebreak[2] доки не~виявиться, що розмір якраз від половини потрібного до потрібного. Це~формально збільшує час виконання кожного запиту від $\Theta(1)$ до $O(\log{N}{+}\log{M})$, але майже\nolinebreak[3] не\nolinebreak[3] впливає на реальний сумарний час виконання, виміряний у мілісекундах. Так~буває (тим~п\'{а}че, що $O(\log{N}{+}\log{M})$\nolinebreak[3] --- не\nolinebreak[3] багато, а\nolinebreak[2] логарифм\nolinebreak[3] --- повільна функція).
Ліві-верхні клітинки \mbox{4-х}\nolinebreak[3] прямокутників повинні мати індекси, схожі на
$(i_1; j_1)$, 
$(i_1; j_2\,{-}\,2^b\,{+}\,1)$,
$(i_2\,{-}\,2^a\,{+}\,1; j_1)$, 
$(i_2\,{-}\,2^a\,{+}\,1; j_2\,{-}\,2^b\,{+}\,1)$ 
(можливо, якось модифіковані згідно з тим, яка у Вас нумерація в масивах), тобто частина прив'язані до верхнього рядка~/ лівого стовпчика, частина\nolinebreak[3] --- до нижнього рядка~/ правого стовпчика та розміру. Насамкінець, обчислення \emph{степенів двійки} може бути реалізовано значно точніше\&швидше, ніж для інших основ. Завдяки тому, що комп'ютери 
% на <<низьких>> (близьких до <<заліза>>, а~не~спілкування з людиною) рівнях 
використовують двійкову систему числення, а\nolinebreak[2] $2^a$\nolinebreak[3] являє собою ${1\underbrace{00\dots0}_{a\textnormal{\begin{footnotesize}~штук\end{footnotesize}}}}{\:(Bin)}$, $2^a$\nolinebreak[3] можна виразити як \textsl{<<узяти (двійкову) одиничку й дописати $a$~нулів>>}. У~Паскалі відповідний оператор називається \texttt{shl} (від\nolinebreak[3] \mbox{\underline{\emph{sh}}ift}\nolinebreak[3] \mbox{\underline{\emph{l}}eft}), у~решті мов програмування, про які автору задачі відомо, що там таке~є, як~``\texttt{\mbox{<}\mbox{<}}'' (два знаки ``менше'', записані підряд). Тож, наприклад, ${i_2\,{-}\,2^a\,{+}\,1}$ можна виразити\nolinebreak[2] як\nolinebreak[2] \mbox{``\texttt{i2-(1{<}{<}a)+1}''} чи\nolinebreak[2] \mbox{``\texttt{i2-(1 shl a)+1}''} (Паскаль). 
% % % (Само собою, якщо підбирати\nolinebreak[3] $a$,~$b$ циклом, можна запам'ятовувати 
% % % обидва результати циклу й не~потребувати піднесення двійки до степеню; 
% % % але\nolinebreak[2] у\nolinebreak[3] \emph{деяких} реалізаціях таке піднесення все~ж потрібне.)



\MyParagraph{Абсолютно альтернативний підхід, який ледь не набрав 100$\,$\% балів.}
Цей підхід у деяких смислах трохи нечесний, але все~ж заслуговує згадки. Повернімось до <<лобового>> підходу (перебирати для кожного прямокутника-запиту всі його елементи) і задумаймося, \emph{коли} він працює \emph{особливо} погано\nolinebreak[2] (довго). Очевидно, коли прямокутник-запит великий. А~коли прямокутник-запит великий, то логічно припустити, що максимум серед нього буде близьким до максимуму серед усього масиву. Так~що можна зробити так: прочитавши вхідні дані, і\nolinebreak[3] пам'ятати їх у звичайному двовимірному масиві, і\nolinebreak[3] сформувати масив трійок вигляду (номер рядка; номер стовпчика; значення) та відсортувати цей масив трійок за\nolinebreak[2] незро\-с\-та\-н\-ням (від\nolinebreak[2] більших до менших) п\'{о}ля <<значення>>; при використанні ефективного сортування це займе $O(M{\cdot}N{\cdot}\log{(M{\cdot}N)})$ часу. Для кожного запиту, спочатку рахувати розмір прямокутника-запиту ${(i_2\,{-}\,i_1\,{+}\,1)}\dibbb{{\times}}{(j_2\,{-}\,j_1\,{+}\,1)}$, і\nolinebreak[3] до\nolinebreak[3] деякої <<планки>> (якої? \mbox{неясно}, треба пробувати різні) запускати <<лобовий>> перебір всіх елементів прямокутника-запиту, а\nolinebreak[3] при\nolinebreak[2] її\nolinebreak[2] перевищенні запускати лінійний пошук за цим відсортованим масивом, тобто дивитися ці трійки від початку (найбільшого значення) послідовно, доки\nolinebreak[3] не\nolinebreak[3] знайдеться трійка, індекси якої потрапляють всер\'{е}дину прямокутника; поле <<значення>> цієї трійки і\nolinebreak[3] буде відповіддю на запит, бо щодо всіх більших значень усього початкового масиву було встановлено, що вони не~належать прямокутнику-запиту.

Для цього алгоритму дуже важко вивести асимптотичну оцінку, бо важко оцінити, скільки треба пропустити трійок, щоб чергова потрапила в\nolinebreak[3] м\'{е}жі прямокутника-запиту (очевидно, в~найгіршому випадку це можуть бути всі елементи початкового масиву, що\nolinebreak[2] не~належать прямокутнику-запиту; але просто неможливо, щоб завжди так і було для різних прямокутників-запитів, які накладаються лише частково чи не~перетинаються взагалі). Поки значення елементів масиву вхідних даних генерувалися випадково з рівномірним розподілом, однаковим для всіх індексів, такий розв'язок, хоч і програвав за часом найкращому згаданому, проходив абсолютно всі тести. Але він усе-таки не~є \emph{завжди} ефективним, тому було прийнято рішення додати контрприклад спеціально проти цього підходу. Суть цього контрприкладу\nolinebreak[3] --- значення елементів масиву ніби й випадкові, але діапазон, з якого випадково вибирається значення, залежить від індексів (чим ближче до краю, тим більша верхня межа). Таким чином, за~рахунок зсуву розподілів значно збільшується середня кількість трійок, які треба розглянути, перш ніж трапиться належна поточному прямокутнику-запиту; разом з тим, завдяки тому, що певна випадковість лишається, тест не~вихолощується до того, щоб максимум завжди був лише в кутках (чи~навіть лише на межах) прямокутника-запиту.

Оскільки такий алгоритм виявився досить добрим у~середньому, щоб <<ламатися>> \emph{лише} на тестах, спеціально сконструйованих проти нього, було прийняте рішення додати такий контрприклад лише\nolinebreak[2] в\nolinebreak[2] останній блок тестів, а\nolinebreak[3] в~передостанній не~додавати, тож 80$\,$\%\nolinebreak[3] балів він набирає.
Але рішення <<ладно, нехай він проходить передостанній блок>> було досить волюнтаристським, його неможливо строго вивести з правил олімпіади. Відповідно, учасник, яким би розумним та досвідченим не~був, не~може адекватно оцінити, які блоки пройде такий розв'язок, доки\nolinebreak[3] не\nolinebreak[3] здасть його в\nolinebreak[3] ejudge. Том\'{у}, написання такого роду розв'язків незрозумілої асимптотичної складності малоприємне, бо є ризик, витративши на нього купу зусиль, отримати ту~ж кількість балів, що й за <<лобовий>> підхід\dots