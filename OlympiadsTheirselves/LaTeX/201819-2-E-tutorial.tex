\Tutorial % \MyParagraph{Розв'язок на 75\%.}
Оскільки гра та~с\'{а}ма, що в попередній задачі, 
% повний розв'язок має 
варто
спиратися на ті\nolinebreak[3] с\'{а}мі виграшні та програшні позиції, що 
% описані в розборі попередньої 
в попередній
задачі; організація циклу <<грати, доки хтось не~виграє>>, елементарна й не~потребує розгляду.
Тож лишаються тільки дрібні зауваження.

Чи~краще визначити, які позиції виграшні й які програшні, один раз на~початку, чи переобчислювати на кожному ході?
Якщо раптом виграшність\nolinebreak\hspace{0pt plus 1pt}/\nolinebreak[2]\hspace{0pt plus 1pt}про\-граш\-ність перевіряє згадана в~самому кінці розбору попередньої задачі рекурсія з за\-пам'\-я\-то\-ву\-ва\-н\-ня\-ми, то варто щоразу запускати рекурсію (раптом суперник вибере хід, який не~був прорахований при аналізі початкової ситуації), але\nolinebreak[2] не~чистячи\nolinebreak[2] \texttt{map} (те, що вже зберігається в ньому після аналізу попередніх ходів, лишається правильним і може допомогти скоротити повторні обчислення).
У~решті випадків, зазвичай краще обчислити один раз і надалі лише бр\'{а}ти готові відповіді (це\nolinebreak[3] не~відповідає тому, як грала~б людина\dots{} але далеко не~завжди варто моделювати поведінку людини; людині важко й рахувати точну кількість паличок, коли їх багато).
Втім, вибір між єдино- і багатократним визначенням виграшності\nolinebreak\hspace{0pt plus 1pt}/\nolinebreak[2]\hspace{0pt plus 1pt}про\-граш\-но\-сті важливий, \emph{лише} якщо користуватися не~дуже ефективним алгоритмом.
Якщо алгоритм досить ефективний (наприклад, заповнення масиву \texttt{minWinS} кодом зі стор.~\pageref{code:201819-2-D-sticks-with-spec-moves-calc-minWinS}), навіть багатократним його використанням можна знехтувати у порівнянні з часом на комунікацію з програмою-суперницею.

% % % Крім того, якщо трапиться таке поєднання одночасно двох умов, що і перевірка виграшності\nolinebreak\hspace{0pt plus 1pt}/\nolinebreak[2]\hspace{0pt plus 1pt}про\-граш\-ності робиться способом з~\mbox{map}-ами, описаним наприкінці розбору минулої задачі, і тест є таким, де треба перехоплювати ініціативу в програми-суперниці, яка отримала виграшну позицію, але не~вміє цим скористатися, то в процесі гри може виникати потреба дослідити деякі з позицій, пропущених при початковому аналізі, тож с\'{а}ме в такій ситуації стає доцільним і~користуватися на проміжних ходах раніше побудованою частиною \texttt{map}-а, і~добудовувати його по мірі потреби.

У~розборі схожої гри на стор.~\pageref{text:random-in-simple-sticks-game} наголошувалося, що для проходження всіх тестів треба грати проти різних безграмотних програм-суперниць, і, щоб одна й та сама наша програма вміла перехоплювати ініціативу в будь-якої з них, при ході з програшної позиції варто ходити випадковим чином. В~цій задачі значно складніша залежність, які позиції виграшні й які програшні, й автору задачі не~вдалося придумати, якою мала\nolinebreak[3] би\nolinebreak[2] бути програма-суперниця, щоб використання нашою програмою випадкових чисел значно полегшувало перехоплення ініціативи у~неї. 
% % % Якщо Ваша програма вміє правильно визначати 
% % % виграшність\nolinebreak\hspace{0pt plus 1pt}/\nolinebreak[2]\hspace{0pt plus 1pt}про\-граш\-ність, 
% % % а програма-суперниця не~вміє, в~цій задачі, начебто, все перехоплюється й без випадкових чисел. 
% % % А~у~суперниць, котрі правильно визначають 
% % % виграшність\nolinebreak\hspace{0pt plus 1pt}/\nolinebreak[2]\hspace{0pt plus 1pt}про\-граш\-ність, нічого не~перехопиш. 
Так\nolinebreak[3] що в\nolinebreak[3] цій задачі, начебто, не~важливо, чи~користуватися випадковими числами при ході з програшної позиції. Незважаючи на те, що це було справді важливо, щоб пройти абсолютно всі тести тієї задачі.
%%% Важливо лише визначати, які позиції виграшні та які програшні (що,~втім, було важливо й у тій задачі).

Насамкінець, якщо не~вміти правильно визначати, які позиції виграшні й які програшні, справді великих балів не~набрати ні за цю задачу, ні за попередню; але, враховуючи особливості їх оцінювання, набирати \emph{частину} балів на цій задачі значно легше, ніж на попередній. По-перше, нарахування балів за окремі тести (а~не~блоки) збільшує ймовірність отримати бали за~те, що в деяких окремих тестах Ваша програма виграє випадково. (Враховуючи, що не~в~усіх тестах програма-суперниця грає ідеально, це цілком можливо.) По-друге, за рахунок того, що 20\%\nolinebreak[3] балів нараховується навіть за те, що програма правильно згідно правил програє там, де могла~б виграти: написати програму, яка лише дотримується правил гри, не~переймаючись своїми шансами виграти, значно легше, ніж розв'язувати задачу по~суті. А\nolinebreak[3] є\nolinebreak[3] ж\nolinebreak[2] ще\nolinebreak[2] тести, в\nolinebreak[3] яких і\nolinebreak[3] слід програти\nolinebreak[3] --- с\'{а}ме за них така проста програма має взяти повні бали.