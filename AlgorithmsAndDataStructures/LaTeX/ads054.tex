Нехай потрібно мати справу з незваженим неорієнтованим мультиграфом, причому в ньому дуже багато вершин і не~дуже багато ребер. Причому, для повного щастя цей мультиграф {\it динамічний}, тобто змінний у часі: іноді приходять запити, що потрібно додати ребро між вершинами $v[j]$ та $v[k]$ (якщо ребро вже~є --- додати ще~одне, на те і мультиграф) або вилучити ребро між вершинами $v[j]$ та $v[k]$ (якщо ребер кілька --- має стати на одне менше; якщо одне --- має не~стати; якщо і так не~було --- так і лишається, що нема, бо навіть у мультиграфі кількість ребер не~може бути від’ємною).

Раз «дуже багато вершин і не~дуже багато ребер», однозначно не~варто користуватися матрицею суміжності, а слід користуватися деяким аналогом списків суміжності. Але якщо можливо, що з деяких вершин може виходити по багато ребер, то при традиційній реалізації списків суміжності операція вилучення ребер буде надто повільною. Тому в такій ситуації може бути доцільним поєднання ідеї списків суміжності з іншими, чим масив або List, структурами даних. Як це найкраще робити мовою C\# --- питання відкрите, але, наприклад, можна розглянути спосіб {\tt Dictionary<int,int>[]}, де кожен окремо взятий {\tt Dictionary<int,int>} описує, куди йдуть р{\it е}бра з поточної вершини графа, причому ключами є номери тих вершин, куди йдуть р{\it е}бра, а значеннями --- кількості таких ребер.)

Напишіть програму, яка оброблятиме послідовність запитів таких видів:

\begin{itemize}
\item
    {\tt RESET\_GRAPH} {\it num} --- створити новий граф, що містить {\it num} вершин (з 0-ої по ({\it num}–1)-у) і не~містить жодного ребр{\it а}. Якщо перед цим вже зберігався якийсь граф, він знищується. Дія відбувається лише у пам’яті, нічого не~виводиться.
\item
    {\tt ADD} {\it j k} --- додати до неорієнтованого мультиграфа ребро $\{v[j], v[k]\}$. Дія відбуваються лише у пам’яті, нічого не~виводиться.
\item
    {\tt DEL} {\it j }k --- вилучити з неорієнтованого мультиграфа ребро $\{v[j], v[k]\}$. Якщо це можливо, тобто між цими вершинами є хоча б одне ребро, то дія відбувається лише у пам’яті, на екран нічого не виводиться. Якщо це неможливо, тобто між цими вершинами нема жодного ребр{\it а}, на екран виводиться повідомлення ``{\tt CNNT}'' (великими літерами, скорочено від ``CANNOT''), а дані в пам’яті не~змінюються.
\item
    {\tt CHK} {\it j k} --- перевірити, чи існує ребро, яке з’єднує вершини $v[j]$ та $v[k]$. Треба вивести  велику латинську літеру ``{\tt Y}'' або ``{\tt N}'' (скорочено від ``YES''/``NO''); дані в пам’яті при цьому не~змінюються.
\item
    {\tt CHECK\_PATH} {\it j k} — перевірити, чи існує шлях довільної довжини, який з’єднує вершини $v[j]$ та $v[k]$. Треба вивести слово ``{\tt YES}'' або ``{\tt NO}'' (великими літерами); дані в пам’яті при цьому не~змінюються.
\end{itemize}

\InputFile
У вхідних даних записано послідовність запитів RESET\_GRAPH, ADD, DEL, CHK та CHECK\_PATH --- кожен у окремому рядку, згідно вищеописаного формату. Першим гарантовано йде RESET\_GRAPH, далі порядок запитів довільний. При кожному запиті ADD, DEL, CHK або CHECK\_PATH вказуються два різні номери вершин від 0 до {\it num}–1, де {\it num} --- кількість вершин поточного графа (згідно останнього виконаного запиту RESET\_GRAPH). Кількість запитів ніде не вказана. Відомо, що при перевірці на великих вхідних даних запитів ADD, DEL та CHK буде дуже багато, а запитів RESET\_GRAPH та CHECK\_PATH — лише по кілька штук.

\OutputFile
Виведіть повідомлення згідно описаних у форматах запитів правил. Кожне повідомлення слід виводити в окремому рядку.


\Examples

\begin{example}
\exmp{RESET\_GRAPH 3
ADD 0 1
ADD 0 1
ADD 1 2
CHK 0 2
CHECK\_PATH 0 2
DEL 1 2
DEL 1 2
ADD 0 2
RESET\_GRAPH 7
CHECK\_PATH 0 2}{N
YES
CNNT
NO}  
\end{example}
             

\Note

В першому тесті відповідь ``N'' (однолітерна) видається на запит ``CHK 0 2'', ``YES'' — на запит ``CHECK\_PATH 0 2'', ``CNNT'' — на другий із запитів ``DEL 1 2'', ``NO'' (слово) — на останній із запитів ``CHECK\_PATH 0 2''. 