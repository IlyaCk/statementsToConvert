{\bf Попередження.} Ця задача може досить легко розв'язуватися одними мовами програмування, і значно важче --- іншими. Автору задачі твердо відомо, що її легко розв'язати мовою {\tt C++} з використанням STL-контейнера {\tt set} чи мовою {\tt Java} з використанням колекції {\tt TreeSet}. Наскільки відомо автору задачі, її не~можна легко розв'язати ні~мовою {\tt Python}, ні~мовою {\tt C\#}, бо відповідні типи чи колекції ({\tt Python set}, {\tt C\# HashSet}, {\tt C\# SortedSet}, \dots) тупо не~містять потрібних для цієї задачі методів, які є в {\tt C++ STL std::set} та {\tt Java TreeSet}. Звісно, ніщо не~заважає написати повністю свій аналог цих класів своєю мовою програмування, але це істотно складніше, чим використати готові методи готового бібліотечного типу. Чи~є інші, крім перелічених, мови програмування, де цю задачу все-таки можна розв'язати легко, автор задачі не~знає.

{\it Кінець попередження.}

Напишіть програму, яка виконуватиме послідовність запитів виду {\tt ADD} {\it num}, {\tt PRESENT} {\it num} та {\tt COUNT} (без параметра). Програму обов'язково слід писати за допомогою бібліотечного типу (колекції) set (її реалізації в~конкретних мовах програмування можуть називатися {\tt HashSet}, {\tt TreeSet}, {\tt SortedSet},~\dots).

Виконання кожного запиту виду {\tt ADD} {\it num} має додавати елемент {\it num} у~множину (якщо такий елемент вже~є, додавання ще~однієї копії не~змінює множину), на~екран при цьому нічого не~виводиться.

При виконанні кожного запиту виду {\tt PRESENT} {\it num} має видаватися повідомлення {\tt YES} (великими літерами, в окремому рядку), якщо таке число наявне у множині (як елемент). Якщо ж такого елемента у множині немає, то в окремому рядку має бути виведено спочатку слово {\tt NO} (великими літерами), кома і один пробіл, а потім або слово {\tt EMPTY} (великими літерами), яке позначає, що множина порожня, або нерівність, яка показує найближчі елементи, що знаходяться у множині. Якщо множина містить і~менший, і~більший елементи, нерівність має бути подвійною, а~якщо елемент із поточного запиту менше мінімального або більше максимального~--- одинарною. Значення множини при виконанні запиту {\tt PRESENT} не~змінюється.

При виконанні кожного запиту виду {\tt COUNT} має видаватися на екран в~окремому рядку кількість різних елементів у~множині; значення множини при цьому не~змінюється.


\InputFile

У першому рядку задано кількість запитів $N$ ($1 < N < 500\,000$), далі йдуть $N$ рядків, кожен з яких містить по одному запиту згідно з описаним форматом.

Значення чисел є цілими й належать діапазону знакового 32-бітового цілого типу (в~більшості мов програмування, це тип {\tt int}).


\OutputFile

Виводьте окремими рядками результати запитів {\tt PRESENT} та {\tt COUNT}; на запити {\tt ADD} нічого не~виводьте.

Зверніть увагу, що у випадку виведення символів {\tt <} довкола них не можна ставити пробіли. 

\Examples

\begin{example}
\exmp{12
COUNT
PRESENT 3
ADD 2
ADD 5
PRESENT 3
PRESENT 1
PRESENT 17
COUNT
ADD 3
ADD 5
PRESENT 3
COUNT
}{0
NO, EMPTY
NO, 2<3<5
NO, 1<2
NO, 5<17
2
YES
3
}
\end{example}

{\bf Попередження.} Ця задача може досить легко розв'язуватися одними мовами програмування, і значно важче --- іншими. Автору задачі твердо відомо, що її легко розв'язати мовою {\tt C++} з використанням STL-контейнера {\tt set} чи мовою {\tt Java} з використанням колекції {\tt TreeSet}. Наскільки відомо автору задачі, її не~можна легко розв'язати ні~мовою {\tt Python}, ні~мовою {\tt C\#}, бо відповідні типи чи колекції ({\tt Python set}, {\tt C\# HashSet}, {\tt C\# SortedSet}, \dots) тупо не~містять потрібних для цієї задачі методів, які є в {\tt C++ STL std::set} та {\tt Java TreeSet}. Звісно, ніщо не~заважає написати повністю свій аналог цих класів своєю мовою програмування, але це істотно складніше, чим використати готові методи готового бібліотечного типу. Чи~є інші, крім перелічених, мови програмування, де цю задачу все-таки можна розв'язати легко, автор задачі не~знає.

{\it Кінець попередження.}
