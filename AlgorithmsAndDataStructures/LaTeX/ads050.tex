Напишіть програму, яка реалізовуватиме у бінарному дереві пошуку дії «вставити» та «знайти» (за~значенням). Програма повинна виконувати  послідовність запитів вигляду ``{\tt ADD} {\it n}'', ``{\tt SEARCH} {\it n}'', та ``{\tt PRINTTREE}'', де {\it n} --- натуральне число.

Для кожного запиту ``{\tt ADD} {\it n}'' слід виконати такі дії: якщо вказаного числа ще нема в дереві, вставити у дерево і вивести на екран слово ``{\tt DONE}'', якщо вже є --- залишати дерево як було (не~вставляти додаткову копію) і виводити на екран слово ``{\tt ALREADY}''.

Для кожного запиту ``{\tt SEARCH} {\it n}'' слід виводити на екран слово ``{\tt YES}'' (якщо значення знайдене у дереві) або слово ``{\tt NO}'' (якщо не~знайдене); при виконанні запитів {\tt SEARCH} дерево не~змінюється.

Для кожного запиту ``{\tt PRINTTREE}'' слід виводити на екран усе дерево, обов’язково дотримуючись того ж формату, що й наведений далі алгоритм.

\InputFile
В кожному рядку вхідних даних записаний один із запитів ``{\tt ADD} {\it n}'', або ``{\tt SEARCH} {\it n}'', або ``{\tt PRINTTREE}'' (без лапок; слова записані великими латинськими буквами; для запитів {\tt ADD} та {\tt SEARCH} число відділене від слова одинарним пробілом і перебуває в межах від 1 до 1234567890). Гарантується, що запити {\tt PRINTTREE} будуть лише у моменти, коли дерево не~порожнє. Загальна кількість запитів не~перевищує~1000, з них не~більше~20 запитів {\tt PRINTTREE}.

\OutputFile
Для кожного запиту виводити відповідь на нього. Для запитів {\tt ADD} та {\tt SEARCH} --- відповідне слово в окремому рядку (великими латинськими буквами, без лапок). На запит {\tt  PRINTTREE} треба виводити дерево, обов’язково відповідно до такого алгоритму:

\begin{verbatim}
public void PrintTree(Node root, int level)
{
    if (root == null)
        return;
    PrintTree(root.left, level + 1);
    Console.WriteLine(new String('.', level) + root.Data);
    PrintTree(root.right, level + 1);
}
\end{verbatim}

% {\tt\\
% public void PrintTree(Node root, int level)\\
% \{\\
    % if (root == null)\\
% ~~~~~~~~return;\\
% ~~~~PrintTree(root.left, level + 1);\\
% ~~~~Console.WriteLine(new String('.', level) + root.Data);\\
% ~~~~PrintTree(root.right, level + 1);\\
% \}
% }

(Початковий виклик цього методу --- {\tt PrintTree(root,~0)}. Якщо описати цей алгоритм словами, вийде приблизно так: слід виводити спочатку ліве піддерево, потім корінь, потім праве піддерево, і результат виходить впорядкованим згори донизу так, як при класичному зображенні мав би бути впорядкований зліва направо; перед кожним елементом треба виводити стільки крапочок, який це ярус, вважаючи, що корінь є єдиним елементом ярусу 0 (слід взагалі не ставити крапочок), сини кореня є елементами ярусу~1 (слід поставити рівно одну крапочку), «онуки» (сини синів) кореня є елементами ярусу~2 (слід поставити рівно дві крапочки), і так далі.) 

\Examples

\begin{example}
\exmp{ADD 2
ADD 3
ADD 2
SEARCH 2
ADD 5
PRINTTREE
SEARCH 7}{DONE
DONE
ALREADY
YES
DONE
2
.3
..5
NO}
\end{example}

\Note
Детальніше пояснимо приклад:

{\tt DONE} --- у відповідь на ADD 2

{\tt DONE} --- у відповідь на ADD 3

{\tt ALREADY} --- у відповідь на ADD 2

{\tt YES} --- у відповідь на SEARCH 2

{\tt DONE} --- у відповідь на ADD 5

{\tt 2} --- цим рядком починається відповідь на {\tt PRINTTREE}

{\tt .3}

{\tt ..5} --- а цим рядком та сама відповідь на той самий {\tt PRINTTREE} закінчується

{\tt NO} --- у відповідь на SEARCH 7
